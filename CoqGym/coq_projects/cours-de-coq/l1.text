Checking Mathematical facts with Coq

A collection of examples

Gilles Kahn

Lesson 1 (ex1.v)
------------------------------

We start with purely logical facts. In Coq,
universal quantification and implication are wired in. All
other logical operators are defined. All variables must be 
given a type. Logical facts have the type Prop.

Goals appear as

Conclusion
---------
Context

A context is a list declarations: variables with their type,
hypothesis with their statement.

Example ``trivial''.

Intro pushes variables or hypotheses in the context.
Use Exact if you know which hypothesis matches the conclusion,
use Assumption to search in the context.

Example ``and_commutative''.

After the ritual intros, to prove the conjuction of two
facts, you should prove each one separately.
You can use Split for that. Split is a nice name,
to say that you use the theorem that defines ``and''.
This theorem is called ``conj''. Compare the effect of
Split with that of Apply ``conj''. Check what ``conj''
is. If you Print ``conj'' instead of only checking it,
you will get its proof as well. Luckily here it is not too big.

You have now two  goals. You can attack them in either order.
Tne context contains the Hypothesis ``A and B'', which is clearly
stronger than either conclusion. Extracting information
from an hypothesis is the job of the Elim command. See what it does.
You should be able to conclude the proof.

The proof seems a bit long because you  do basically the same thing
in both subgoals. May be you could have extracted
first the information from the context, then split the conclusion
and searched for the relevant hypothesis, in both subgoals.

Hint: in Coq, the command ``foo; bar'' means: do ``foo''; then
do ``bar'' on ALL subgoals generated by ``foo''. So your command 
script should finish with 
Split; Assumption.

Example ``or_commutative''

In this case, you must absolutely exploit the fact that
there is a disjunction in an hypothesis, leading to a case
analysis. The two cases are handled by the command Right and Left
which are sugar for for Apply or_intror and Apply or_intro_r.
Check these theorems.


Example ``mp''

After intros, there are two strategies. The first one, called
``goal directed'' or ``backward'', consists in finding a fact that has B
at the end of an implication chain. The second one, called ``forward''
consists in working in the context, to deduce  further facts.

Try the first method. Remember this: Hypotheses and Theorems are handled 
exactly alike. Hyptheses are local to a sequent while theorems are global.
If H is the name of the implication A->B, you can Apply H, and conclude.

Try the second method by clicking on A in H.

Print the proof of theorem mp in both cases? What do you see?

Example ``S''

This example is very similar to the previous one.
It is called S because if you understand forall as lambda,
and implies as application, this is just the S combinator of 
lambda-calculus.


Example Praeclarum

Combine what you learned from and_commutative and mp to prove this
fact.

Example resolution

This is now a first order statement. We introduce two predicate
symbols p and q. Notice the types of p and q. The same arrow is used for
types and implication. 

In mp and S, we have used Apply when the conclusion exactly matched
the end of an implication chain. But Apply performs first order unification
for you. 

Example Witnesses.
Here we need to import a Coq package called Logic_Type, because
the existential quantifier on Type is defined there.

There are two cases, so this begins  like in or_commutative.
But, to prove that something exists, Coq needs a witness,
which is provided as an argument of Exists. In one case
it is a, in the other case it is b.

Exists is sugar for Apply exT_intro. Check that theorem.
Use Apply ext_intro with a (resp. b) to prove this example.

Example Simple.

Here, we have a new phenomenon. An existential fact is in
the context. To exploit an hypothesis, as we have seen before,
one must use Elim.


Example not_not.
In Coq, not is not primitive but defined so that
(not A) rewites to  A -> False.  To unfold a symbol
when it is the outermost one, you don't even have to give its name.
After intros ( Intros a H'), Red unfolds the outermost not.
After another Intro (Intro H'0), not is the outermost symbol in 
hypothesis H0, and it is unfolded with Red in H'0.

Sometimes, one wants to unfold all occurrences, or a specific
occurrence of a symbol. Experiment with Unfold not, Unfold 1 not,
Unfold 2 not, Unfold not in H'0, etc...

(Grrr....)

Example mini_cases

Here, what you must know is that when your context
contains both A and not A, you have won, because it is
a contradiction, from which you can deduce anything.

(Grr...
Technically, from A and not A you infer False. Then
you Elim that fact.
)

Example not_not_converse

This fact is not valid in intuitionnistic logic.  In Coq,
you can decide to work with Classical Logic, importing
essentially the axiom of the excluded middle, called classic.

Here, you want a particular instance of this axiom, so as to
have a or not a as a new hypothesis.

Example not_quite_classic

This example is here to show that the distance between
intuitionnistic logic and classical logic is thin sometimes,
since although classic is not valid, not_quite_classic is.

With this proof, the game of logic may seem carried 
a bit too far. Look at the proof (not the script), 
you will see that it is perfectly reasonable.

