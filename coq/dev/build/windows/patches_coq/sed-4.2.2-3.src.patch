--- origsrc/sed-4.2.2/doc/sed.1	2012-12-22 15:27:13.000000000 +0100
+++ src/sed-4.2.2/doc/sed.1	2013-06-27 18:10:47.974060492 +0200
@@ -1,5 +1,5 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.28.
-.TH SED "1" "December 2012" "sed 4.2.2" "User Commands"
+.TH SED "1" "June 2013" "sed 4.2.2" "User Commands"
 .SH NAME
 sed \- stream editor for filtering and transforming text
 .SH SYNOPSIS
@@ -40,6 +40,10 @@ follow symlinks when processing in place
 .IP
 edit files in place (makes backup if SUFFIX supplied)
 .HP
+\fB\-b\fR, \fB\-\-binary\fR
+.IP
+open files in binary mode (CR+LFs are not processed specially)
+.HP
 \fB\-l\fR N, \fB\-\-line\-length\fR=\fIN\fR
 .IP
 specify the desired line-wrap length for the `l' command
--- origsrc/sed-4.2.2/lib/regcomp.c	2012-12-22 14:21:52.000000000 +0100
+++ src/sed-4.2.2/lib/regcomp.c	2013-06-27 18:05:27.044448044 +0200
@@ -1,22 +1,21 @@
-/* -*- buffer-read-only: t -*- vi: set ro: */
-/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
 /* Extended regular expression matching and search library.
-   Copyright (C) 2002-2012 Free Software Foundation, Inc.
+   Copyright (C) 2002-2013 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Isamu Hasegawa <isamu@yamato.ibm.com>.
 
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3, or (at your option)
-   any later version.
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
 
-   This program is distributed in the hope that it will be useful,
+   The GNU C Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
 
-   You should have received a copy of the GNU General Public License along
-   with this program; if not, see <http://www.gnu.org/licenses/>.  */
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
 
 static reg_errcode_t re_compile_internal (regex_t *preg, const char * pattern,
 					  size_t length, reg_syntax_t syntax);
@@ -95,20 +94,20 @@ static reg_errcode_t build_charclass (RE
 				      bitset_t sbcset,
 				      re_charset_t *mbcset,
 				      Idx *char_class_alloc,
-				      const unsigned char *class_name,
+				      const char *class_name,
 				      reg_syntax_t syntax);
 #else  /* not RE_ENABLE_I18N */
 static reg_errcode_t build_equiv_class (bitset_t sbcset,
 					const unsigned char *name);
 static reg_errcode_t build_charclass (RE_TRANSLATE_TYPE trans,
 				      bitset_t sbcset,
-				      const unsigned char *class_name,
+				      const char *class_name,
 				      reg_syntax_t syntax);
 #endif /* not RE_ENABLE_I18N */
 static bin_tree_t *build_charclass_op (re_dfa_t *dfa,
 				       RE_TRANSLATE_TYPE trans,
-				       const unsigned char *class_name,
-				       const unsigned char *extra,
+				       const char *class_name,
+				       const char *extra,
 				       bool non_match, reg_errcode_t *err);
 static bin_tree_t *create_tree (re_dfa_t *dfa,
 				bin_tree_t *left, bin_tree_t *right,
@@ -293,7 +292,7 @@ weak_alias (__re_compile_fastmap, re_com
 #endif
 
 static inline void
-__attribute ((always_inline))
+__attribute__ ((always_inline))
 re_set_fastmap (char *fastmap, bool icase, int ch)
 {
   fastmap[ch] = 1;
@@ -587,7 +586,7 @@ weak_alias (__regerror, regerror)
 static const bitset_t utf8_sb_map =
 {
   /* Set the first 128 bits.  */
-# ifdef __GNUC__
+# if defined __GNUC__ && !defined __STRICT_ANSI__
   [0 ... 0x80 / BITSET_WORD_BITS - 1] = BITSET_WORD_MAX
 # else
 #  if 4 * BITSET_WORD_BITS < ASCII_CHARS
@@ -664,7 +663,10 @@ regfree (preg)
 {
   re_dfa_t *dfa = preg->buffer;
   if (BE (dfa != NULL, 1))
-    free_dfa_content (dfa);
+    {
+      lock_fini (dfa->lock);
+      free_dfa_content (dfa);
+    }
   preg->buffer = NULL;
   preg->allocated = 0;
 
@@ -785,6 +787,8 @@ re_compile_internal (regex_t *preg, cons
   preg->used = sizeof (re_dfa_t);
 
   err = init_dfa (dfa, length);
+  if (BE (err == REG_NOERROR && lock_init (dfa->lock) != 0, 0))
+    err = REG_ESPACE;
   if (BE (err != REG_NOERROR, 0))
     {
       free_dfa_content (dfa);
@@ -798,8 +802,6 @@ re_compile_internal (regex_t *preg, cons
   strncpy (dfa->re_str, pattern, length + 1);
 #endif
 
-  __libc_lock_init (dfa->lock);
-
   err = re_string_construct (&regexp, pattern, length, preg->translate,
 			     (syntax & RE_ICASE) != 0, dfa);
   if (BE (err != REG_NOERROR, 0))
@@ -807,6 +809,7 @@ re_compile_internal (regex_t *preg, cons
     re_compile_internal_free_return:
       free_workarea_compile (preg);
       re_string_destruct (&regexp);
+      lock_fini (dfa->lock);
       free_dfa_content (dfa);
       preg->buffer = NULL;
       preg->allocated = 0;
@@ -839,6 +842,7 @@ re_compile_internal (regex_t *preg, cons
 
   if (BE (err != REG_NOERROR, 0))
     {
+      lock_fini (dfa->lock);
       free_dfa_content (dfa);
       preg->buffer = NULL;
       preg->allocated = 0;
@@ -954,10 +958,10 @@ static void
 internal_function
 init_word_char (re_dfa_t *dfa)
 {
-  dfa->word_ops_used = 1;
   int i = 0;
   int j;
   int ch = 0;
+  dfa->word_ops_used = 1;
   if (BE (dfa->map_notascii == 0, 1))
     {
       bitset_word_t bits0 = 0x00000000;
@@ -2423,8 +2427,8 @@ parse_expression (re_string_t *regexp, r
     case OP_WORD:
     case OP_NOTWORD:
       tree = build_charclass_op (dfa, regexp->trans,
-				 (const unsigned char *) "alnum",
-				 (const unsigned char *) "_",
+				 "alnum",
+				 "_",
 				 token->type == OP_NOTWORD, err);
       if (BE (*err != REG_NOERROR && tree == NULL, 0))
 	return NULL;
@@ -2432,8 +2436,8 @@ parse_expression (re_string_t *regexp, r
     case OP_SPACE:
     case OP_NOTSPACE:
       tree = build_charclass_op (dfa, regexp->trans,
-				 (const unsigned char *) "space",
-				 (const unsigned char *) "",
+				 "space",
+				 "",
 				 token->type == OP_NOTSPACE, err);
       if (BE (*err != REG_NOERROR && tree == NULL, 0))
 	return NULL;
@@ -2713,7 +2717,6 @@ build_range_exp (const reg_syntax_t synt
     wchar_t wc;
     wint_t start_wc;
     wint_t end_wc;
-    wchar_t cmp_buf[6] = {L'\0', L'\0', L'\0', L'\0', L'\0', L'\0'};
 
     start_ch = ((start_elem->type == SB_CHAR) ? start_elem->opr.ch
 		: ((start_elem->type == COLL_SYM) ? start_elem->opr.name[0]
@@ -2727,11 +2730,7 @@ build_range_exp (const reg_syntax_t synt
 	      ? __btowc (end_ch) : end_elem->opr.wch);
     if (start_wc == WEOF || end_wc == WEOF)
       return REG_ECOLLATE;
-    cmp_buf[0] = start_wc;
-    cmp_buf[4] = end_wc;
-
-    if (BE ((syntax & RE_NO_EMPTY_RANGES)
-            && wcscoll (cmp_buf, cmp_buf + 4) > 0, 0))
+    else if (BE ((syntax & RE_NO_EMPTY_RANGES) && start_wc > end_wc, 0))
       return REG_ERANGE;
 
     /* Got valid collation sequence values, add them as a new entry.
@@ -2772,9 +2771,7 @@ build_range_exp (const reg_syntax_t synt
     /* Build the table for single byte characters.  */
     for (wc = 0; wc < SBC_MAX; ++wc)
       {
-	cmp_buf[2] = wc;
-	if (wcscoll (cmp_buf, cmp_buf + 2) <= 0
-	    && wcscoll (cmp_buf + 2, cmp_buf + 4) <= 0)
+	if (start_wc <= wc && wc <= end_wc)
 	  bitset_set (sbcset, wc);
       }
   }
@@ -2843,40 +2840,29 @@ parse_bracket_exp (re_string_t *regexp,
 
   /* Local function for parse_bracket_exp used in _LIBC environment.
      Seek the collating symbol entry corresponding to NAME.
-     Return the index of the symbol in the SYMB_TABLE.  */
+     Return the index of the symbol in the SYMB_TABLE,
+     or -1 if not found.  */
 
   auto inline int32_t
-  __attribute ((always_inline))
-  seek_collating_symbol_entry (name, name_len)
-	 const unsigned char *name;
-	 size_t name_len;
-    {
-      int32_t hash = elem_hash ((const char *) name, name_len);
-      int32_t elem = hash % table_size;
-      if (symb_table[2 * elem] != 0)
-	{
-	  int32_t second = hash % (table_size - 2) + 1;
-
-	  do
-	    {
-	      /* First compare the hashing value.  */
-	      if (symb_table[2 * elem] == hash
-		  /* Compare the length of the name.  */
-		  && name_len == extra[symb_table[2 * elem + 1]]
-		  /* Compare the name.  */
-		  && memcmp (name, &extra[symb_table[2 * elem + 1] + 1],
-			     name_len) == 0)
-		{
-		  /* Yep, this is the entry.  */
-		  break;
-		}
+  __attribute__ ((always_inline))
+  seek_collating_symbol_entry (const unsigned char *name, size_t name_len)
+    {
+      int32_t elem;
 
-	      /* Next entry.  */
-	      elem += second;
-	    }
-	  while (symb_table[2 * elem] != 0);
-	}
-      return elem;
+      for (elem = 0; elem < table_size; elem++)
+	if (symb_table[2 * elem] != 0)
+	  {
+	    int32_t idx = symb_table[2 * elem + 1];
+	    /* Skip the name of collating element name.  */
+	    idx += 1 + extra[idx];
+	    if (/* Compare the length of the name.  */
+		name_len == extra[idx]
+		/* Compare the name.  */
+		&& memcmp (name, &extra[idx + 1], name_len) == 0)
+	      /* Yep, this is the entry.  */
+	      return elem;
+	  }
+      return -1;
     }
 
   /* Local function for parse_bracket_exp used in _LIBC environment.
@@ -2884,9 +2870,8 @@ parse_bracket_exp (re_string_t *regexp,
      Return the value if succeeded, UINT_MAX otherwise.  */
 
   auto inline unsigned int
-  __attribute ((always_inline))
-  lookup_collation_sequence_value (br_elem)
-	 bracket_elem_t *br_elem;
+  __attribute__ ((always_inline))
+  lookup_collation_sequence_value (bracket_elem_t *br_elem)
     {
       if (br_elem->type == SB_CHAR)
 	{
@@ -2914,7 +2899,7 @@ parse_bracket_exp (re_string_t *regexp,
 	      int32_t elem, idx;
 	      elem = seek_collating_symbol_entry (br_elem->opr.name,
 						  sym_name_len);
-	      if (symb_table[2 * elem] != 0)
+	      if (elem != -1)
 		{
 		  /* We found the entry.  */
 		  idx = symb_table[2 * elem + 1];
@@ -2932,7 +2917,7 @@ parse_bracket_exp (re_string_t *regexp,
 		  /* Return the collation sequence value.  */
 		  return *(unsigned int *) (extra + idx);
 		}
-	      else if (symb_table[2 * elem] == 0 && sym_name_len == 1)
+	      else if (sym_name_len == 1)
 		{
 		  /* No valid character.  Match it as a single byte
 		     character.  */
@@ -2953,12 +2938,9 @@ parse_bracket_exp (re_string_t *regexp,
      update it.  */
 
   auto inline reg_errcode_t
-  __attribute ((always_inline))
-  build_range_exp (sbcset, mbcset, range_alloc, start_elem, end_elem)
-	 re_charset_t *mbcset;
-	 Idx *range_alloc;
-	 bitset_t sbcset;
-	 bracket_elem_t *start_elem, *end_elem;
+  __attribute__ ((always_inline))
+  build_range_exp (bitset_t sbcset, re_charset_t *mbcset, int *range_alloc,
+		   bracket_elem_t *start_elem, bracket_elem_t *end_elem)
     {
       unsigned int ch;
       uint32_t start_collseq;
@@ -2971,6 +2953,7 @@ parse_bracket_exp (re_string_t *regexp,
 	      0))
 	return REG_ERANGE;
 
+      /* FIXME: Implement rational ranges here, too.  */
       start_collseq = lookup_collation_sequence_value (start_elem);
       end_collseq = lookup_collation_sequence_value (end_elem);
       /* Check start/end collation sequence values.  */
@@ -3036,26 +3019,23 @@ parse_bracket_exp (re_string_t *regexp,
      pointer argument since we may update it.  */
 
   auto inline reg_errcode_t
-  __attribute ((always_inline))
-  build_collating_symbol (sbcset, mbcset, coll_sym_alloc, name)
-	 re_charset_t *mbcset;
-	 Idx *coll_sym_alloc;
-	 bitset_t sbcset;
-	 const unsigned char *name;
+  __attribute__ ((always_inline))
+  build_collating_symbol (bitset_t sbcset, re_charset_t *mbcset,
+			  Idx *coll_sym_alloc, const unsigned char *name)
     {
       int32_t elem, idx;
       size_t name_len = strlen ((const char *) name);
       if (nrules != 0)
 	{
 	  elem = seek_collating_symbol_entry (name, name_len);
-	  if (symb_table[2 * elem] != 0)
+	  if (elem != -1)
 	    {
 	      /* We found the entry.  */
 	      idx = symb_table[2 * elem + 1];
 	      /* Skip the name of collating element name.  */
 	      idx += 1 + extra[idx];
 	    }
-	  else if (symb_table[2 * elem] == 0 && name_len == 1)
+	  else if (name_len == 1)
 	    {
 	      /* No valid character, treat it as a normal
 		 character.  */
@@ -3298,7 +3278,8 @@ parse_bracket_exp (re_string_t *regexp,
 #ifdef RE_ENABLE_I18N
 				      mbcset, &char_class_alloc,
 #endif /* RE_ENABLE_I18N */
-				      start_elem.opr.name, syntax);
+				      (const char *) start_elem.opr.name,
+				      syntax);
 	      if (BE (*err != REG_NOERROR, 0))
 	       goto parse_bracket_exp_free_return;
 	      break;
@@ -3578,14 +3559,14 @@ static reg_errcode_t
 #ifdef RE_ENABLE_I18N
 build_charclass (RE_TRANSLATE_TYPE trans, bitset_t sbcset,
 		 re_charset_t *mbcset, Idx *char_class_alloc,
-		 const unsigned char *class_name, reg_syntax_t syntax)
+		 const char *class_name, reg_syntax_t syntax)
 #else /* not RE_ENABLE_I18N */
 build_charclass (RE_TRANSLATE_TYPE trans, bitset_t sbcset,
-		 const unsigned char *class_name, reg_syntax_t syntax)
+		 const char *class_name, reg_syntax_t syntax)
 #endif /* not RE_ENABLE_I18N */
 {
   int i;
-  const char *name = (const char *) class_name;
+  const char *name = class_name;
 
   /* In case of REG_ICASE "upper" and "lower" match the both of
      upper and lower cases.  */
@@ -3659,8 +3640,8 @@ build_charclass (RE_TRANSLATE_TYPE trans
 
 static bin_tree_t *
 build_charclass_op (re_dfa_t *dfa, RE_TRANSLATE_TYPE trans,
-		    const unsigned char *class_name,
-		    const unsigned char *extra, bool non_match,
+		    const char *class_name,
+		    const char *extra, bool non_match,
 		    reg_errcode_t *err)
 {
   re_bitset_ptr_t sbcset;
--- origsrc/sed-4.2.2/lib/regex-quote.c	1970-01-01 01:00:00.000000000 +0100
+++ src/sed-4.2.2/lib/regex-quote.c	2013-06-27 18:05:27.081447884 +0200
@@ -0,0 +1,216 @@
+/* Construct a regular expression from a literal string.
+   Copyright (C) 1995, 2010-2013 Free Software Foundation, Inc.
+   Written by Bruno Haible <haible@clisp.cons.org>, 2010.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include <config.h>
+
+/* Specification.  */
+#include "regex-quote.h"
+
+#include <string.h>
+
+#include "mbuiter.h"
+#include "xalloc.h"
+
+/* Characters that are special in a BRE.  */
+static const char bre_special[] = "$^.*[]\\";
+
+/* Characters that are special in an ERE.  */
+static const char ere_special[] = "$^.*[]\\+?{}()|";
+
+struct regex_quote_spec
+regex_quote_spec_posix (int cflags, bool anchored)
+{
+  struct regex_quote_spec result;
+
+  strcpy (result.special, cflags != 0 ? ere_special : bre_special);
+  result.multibyte = true;
+  result.anchored = anchored;
+
+  return result;
+}
+
+/* Syntax bit values, defined in GNU <regex.h>.  We don't include it here,
+   otherwise this module would need to depend on gnulib module 'regex'.  */
+#define RE_BK_PLUS_QM    0x00000002
+#define RE_INTERVALS     0x00000200
+#define RE_LIMITED_OPS   0x00000400
+#define RE_NEWLINE_ALT   0x00000800
+#define RE_NO_BK_BRACES  0x00001000
+#define RE_NO_BK_PARENS  0x00002000
+#define RE_NO_BK_VBAR    0x00008000
+
+struct regex_quote_spec
+regex_quote_spec_gnu (unsigned long /*reg_syntax_t*/ syntax, bool anchored)
+{
+  struct regex_quote_spec result;
+  char *p;
+
+  p = result.special;
+  memcpy (p, bre_special, sizeof (bre_special) - 1);
+  p += sizeof (bre_special) - 1;
+  if ((syntax & RE_LIMITED_OPS) == 0 && (syntax & RE_BK_PLUS_QM) == 0)
+    {
+      *p++ = '+';
+      *p++ = '?';
+    }
+  if ((syntax & RE_INTERVALS) != 0 && (syntax & RE_NO_BK_BRACES) != 0)
+    {
+      *p++ = '{';
+      *p++ = '}';
+    }
+  if ((syntax & RE_NO_BK_PARENS) != 0)
+    {
+      *p++ = '(';
+      *p++ = ')';
+    }
+  if ((syntax & RE_LIMITED_OPS) == 0 && (syntax & RE_NO_BK_VBAR) != 0)
+    *p++ = '|';
+  if ((syntax & RE_NEWLINE_ALT) != 0)
+    *p++ = '\n';
+  *p = '\0';
+
+  result.multibyte = true;
+  result.anchored = anchored;
+
+  return result;
+}
+
+/* Characters that are special in a PCRE.  */
+static const char pcre_special[] = "$^.*[]\\+?{}()|";
+
+/* Options bit values, defined in <pcre.h>.  We don't include it here, because
+   it is not a standard header.  */
+#define PCRE_ANCHORED 0x00000010
+#define PCRE_EXTENDED 0x00000008
+
+struct regex_quote_spec
+regex_quote_spec_pcre (int options, bool anchored)
+{
+  struct regex_quote_spec result;
+  char *p;
+
+  p = result.special;
+  memcpy (p, bre_special, sizeof (pcre_special) - 1);
+  p += sizeof (pcre_special) - 1;
+  if (options & PCRE_EXTENDED)
+    {
+      *p++ = ' ';
+      *p++ = '\t';
+      *p++ = '\n';
+      *p++ = '\v';
+      *p++ = '\f';
+      *p++ = '\r';
+      *p++ = '#';
+    }
+  *p = '\0';
+
+  /* PCRE regular expressions consist of UTF-8 characters of options contains
+     PCRE_UTF8 and of single bytes otherwise.  */
+  result.multibyte = false;
+  /* If options contains PCRE_ANCHORED, the anchoring is implicit.  */
+  result.anchored = (options & PCRE_ANCHORED ? 0 : anchored);
+
+  return result;
+}
+
+size_t
+regex_quote_length (const char *string, const struct regex_quote_spec *spec)
+{
+  const char *special = spec->special;
+  size_t length;
+
+  length = 0;
+  if (spec->anchored)
+    length += 2; /* for '^' at the beginning and '$' at the end */
+  if (spec->multibyte)
+    {
+      mbui_iterator_t iter;
+
+      for (mbui_init (iter, string); mbui_avail (iter); mbui_advance (iter))
+        {
+          /* We know that special contains only ASCII characters.  */
+          if (mb_len (mbui_cur (iter)) == 1
+              && strchr (special, * mbui_cur_ptr (iter)))
+            length += 1;
+          length += mb_len (mbui_cur (iter));
+        }
+    }
+  else
+    {
+      const char *iter;
+
+      for (iter = string; *iter != '\0'; iter++)
+        {
+          if (strchr (special, *iter))
+            length += 1;
+          length += 1;
+        }
+    }
+
+  return length;
+}
+
+char *
+regex_quote_copy (char *p, const char *string, const struct regex_quote_spec *spec)
+{
+  const char *special = spec->special;
+
+  if (spec->anchored)
+    *p++ = '^';
+  if (spec->multibyte)
+    {
+      mbui_iterator_t iter;
+
+      for (mbui_init (iter, string); mbui_avail (iter); mbui_advance (iter))
+        {
+          /* We know that special contains only ASCII characters.  */
+          if (mb_len (mbui_cur (iter)) == 1
+              && strchr (special, * mbui_cur_ptr (iter)))
+            *p++ = '\\';
+          memcpy (p, mbui_cur_ptr (iter), mb_len (mbui_cur (iter)));
+          p += mb_len (mbui_cur (iter));
+        }
+    }
+  else
+    {
+      const char *iter;
+
+      for (iter = string; *iter != '\0'; iter++)
+        {
+          if (strchr (special, *iter))
+            *p++ = '\\';
+          *p++ = *iter++;
+        }
+    }
+  if (spec->anchored)
+    *p++ = '$';
+
+  return p;
+}
+
+char *
+regex_quote (const char *string, const struct regex_quote_spec *spec)
+{
+  size_t length = regex_quote_length (string, spec);
+  char *result = XNMALLOC (length + 1, char);
+  char *p;
+
+  p = result;
+  p = regex_quote_copy (p, string, spec);
+  *p = '\0';
+  return result;
+}
--- origsrc/sed-4.2.2/lib/regex-quote.h	1970-01-01 01:00:00.000000000 +0100
+++ src/sed-4.2.2/lib/regex-quote.h	2013-06-27 18:05:27.112447751 +0200
@@ -0,0 +1,88 @@
+/* Construct a regular expression from a literal string.
+   Copyright (C) 1995, 2010-2013 Free Software Foundation, Inc.
+   Written by Bruno Haible <haible@clisp.cons.org>, 2010.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef _REGEX_QUOTE_H
+#define _REGEX_QUOTE_H
+
+#include <stddef.h>
+#include <stdbool.h>
+
+
+/* Specifies a quotation task for converting a fixed string to a regular
+   expression pattern.  */
+struct regex_quote_spec
+{
+  /* True if the regular expression pattern consists of multibyte characters
+     (in the encoding given by the LC_CTYPE category of the locale),
+     false if it consists of single bytes or UTF-8 characters.  */
+  unsigned int /*bool*/ multibyte : 1;
+  /* True if the regular expression pattern shall match only entire lines.  */
+  unsigned int /*bool*/ anchored : 1;
+  /* Set of characters that need to be escaped (all ASCII), as a
+     NUL-terminated string.  */
+  char special[30 + 1];
+};
+
+
+/* Creates a quotation task that produces a POSIX regular expression, that is,
+   a pattern that can be compiled with regcomp().
+   CFLAGS can be 0 or REG_EXTENDED.
+   If it is 0, the result is a Basic Regular Expression (BRE)
+   <http://www.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_03>.
+   If it is REG_EXTENDED, the result is an Extended Regular Expression (ERE)
+   <http://www.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04>.
+   If ANCHORED is false, the regular expression will match substrings of lines.
+   If ANCHORED is true, it will match only complete lines,  */
+extern struct regex_quote_spec
+       regex_quote_spec_posix (int cflags, bool anchored);
+
+/* Creates a quotation task that produces a regular expression that can be
+   compiled with the GNU API function re_compile_pattern().
+   SYNTAX describes the syntax of the regular expression (such as
+   RE_SYNTAX_POSIX_BASIC, RE_SYNTAX_POSIX_EXTENDED, RE_SYNTAX_EMACS, all
+   defined in <regex.h>).  It must be the same value as 're_syntax_options'
+   at the moment of the re_compile_pattern() call.
+   If ANCHORED is false, the regular expression will match substrings of lines.
+   If ANCHORED is true, it will match only complete lines,  */
+extern struct regex_quote_spec
+       regex_quote_spec_gnu (unsigned long /*reg_syntax_t*/ syntax, bool anchored);
+
+/* Creates a quotation task that produces a PCRE regular expression, that is,
+   a pattern that can be compiled with pcre_compile().
+   OPTIONS is the same value as the second argument passed to pcre_compile().
+   If ANCHORED is false, the regular expression will match substrings of lines.
+   If ANCHORED is true, it will match only complete lines,  */
+extern struct regex_quote_spec
+       regex_quote_spec_pcre (int options, bool anchored);
+
+
+/* Returns the number of bytes needed for the quoted string.  */
+extern size_t
+       regex_quote_length (const char *string, const struct regex_quote_spec *spec);
+
+/* Copies the quoted string to p and returns the incremented p.
+   There must be room for regex_quote_length (string, spec) + 1 bytes at p.  */
+extern char *
+       regex_quote_copy (char *p,
+                         const char *string, const struct regex_quote_spec *spec);
+
+/* Returns the freshly allocated quoted string.  */
+extern char *
+       regex_quote (const char *string, const struct regex_quote_spec *spec);
+
+
+#endif /* _REGEX_QUOTE_H */
--- origsrc/sed-4.2.2/lib/regex.c	2012-12-22 14:21:52.000000000 +0100
+++ src/sed-4.2.2/lib/regex.c	2013-06-27 18:05:27.138447639 +0200
@@ -1,22 +1,21 @@
-/* -*- buffer-read-only: t -*- vi: set ro: */
-/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
 /* Extended regular expression matching and search library.
-   Copyright (C) 2002-2003, 2005-2006, 2009-2012 Free Software Foundation, Inc.
+   Copyright (C) 2002-2013 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Isamu Hasegawa <isamu@yamato.ibm.com>.
 
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3, or (at your option)
-   any later version.
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
 
-   This program is distributed in the hope that it will be useful,
+   The GNU C Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
 
-   You should have received a copy of the GNU General Public License along
-   with this program; if not, see <http://www.gnu.org/licenses/>.  */
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
 
 #ifndef _LIBC
 # include <config.h>
@@ -25,6 +24,7 @@
 #  pragma GCC diagnostic ignored "-Wsuggest-attribute=pure"
 # endif
 # if (__GNUC__ == 4 && 3 <= __GNUC_MINOR__) || 4 < __GNUC__
+#  pragma GCC diagnostic ignored "-Wold-style-definition"
 #  pragma GCC diagnostic ignored "-Wtype-limits"
 # endif
 #endif
--- origsrc/sed-4.2.2/lib/regex.h	2012-12-22 14:21:52.000000000 +0100
+++ src/sed-4.2.2/lib/regex.h	2013-06-27 18:05:27.168447509 +0200
@@ -1,23 +1,22 @@
-/* -*- buffer-read-only: t -*- vi: set ro: */
-/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
 /* Definitions for data structures and routines for the regular
    expression library.
-   Copyright (C) 1985, 1989-1993, 1995-1998, 2000-2003, 2005-2012
-   Free Software Foundation, Inc.
+   Copyright (C) 1985, 1989-1993, 1995-1998, 2000-2003, 2005-2013 Free Software
+   Foundation, Inc.
    This file is part of the GNU C Library.
 
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3, or (at your option)
-   any later version.
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
 
-   This program is distributed in the hope that it will be useful,
+   The GNU C Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
 
-   You should have received a copy of the GNU General Public License along
-   with this program; if not, see <http://www.gnu.org/licenses/>.  */
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
 
 #ifndef _REGEX_H
 #define _REGEX_H 1
--- origsrc/sed-4.2.2/lib/regex_internal.c	2012-12-22 14:21:52.000000000 +0100
+++ src/sed-4.2.2/lib/regex_internal.c	2013-06-27 18:05:27.199447375 +0200
@@ -1,22 +1,21 @@
-/* -*- buffer-read-only: t -*- vi: set ro: */
-/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
 /* Extended regular expression matching and search library.
-   Copyright (C) 2002-2012 Free Software Foundation, Inc.
+   Copyright (C) 2002-2013 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Isamu Hasegawa <isamu@yamato.ibm.com>.
 
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3, or (at your option)
-   any later version.
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
 
-   This program is distributed in the hope that it will be useful,
+   The GNU C Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
 
-   You should have received a copy of the GNU General Public License along
-   with this program; if not, see <http://www.gnu.org/licenses/>.  */
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
 
 static void re_string_construct_common (const char *str, Idx len,
 					re_string_t *pstr,
@@ -835,7 +834,7 @@ re_string_reconstruct (re_string_t *pstr
 }
 
 static unsigned char
-internal_function __attribute ((pure))
+internal_function __attribute__ ((pure))
 re_string_peek_byte_case (const re_string_t *pstr, Idx idx)
 {
   int ch;
@@ -975,7 +974,7 @@ re_node_set_alloc (re_node_set *set, Idx
   set->alloc = size;
   set->nelem = 0;
   set->elems = re_malloc (Idx, size);
-  if (BE (set->elems == NULL, 0))
+  if (BE (set->elems == NULL, 0) && (MALLOC_0_IS_NONNULL || size != 0))
     return REG_ESPACE;
   return REG_NOERROR;
 }
@@ -1355,7 +1354,7 @@ re_node_set_insert_last (re_node_set *se
    Return true if SET1 and SET2 are equivalent.  */
 
 static bool
-internal_function __attribute ((pure))
+internal_function __attribute__ ((pure))
 re_node_set_compare (const re_node_set *set1, const re_node_set *set2)
 {
   Idx i;
@@ -1370,7 +1369,7 @@ re_node_set_compare (const re_node_set *
 /* Return (idx + 1) if SET contains the element ELEM, return 0 otherwise.  */
 
 static Idx
-internal_function __attribute ((pure))
+internal_function __attribute__ ((pure))
 re_node_set_contains (const re_node_set *set, Idx elem)
 {
   __re_size_t idx, right, mid;
@@ -1444,11 +1443,9 @@ re_dfa_add_node (re_dfa_t *dfa, re_token
   dfa->nodes[dfa->nodes_len] = token;
   dfa->nodes[dfa->nodes_len].constraint = 0;
 #ifdef RE_ENABLE_I18N
-  {
-  int type = token.type;
   dfa->nodes[dfa->nodes_len].accept_mb =
-    (type == OP_PERIOD && dfa->mb_cur_max > 1) || type == COMPLEX_BRACKET;
-  }
+    ((token.type == OP_PERIOD && dfa->mb_cur_max > 1)
+     || token.type == COMPLEX_BRACKET);
 #endif
   dfa->nexts[dfa->nodes_len] = REG_MISSING;
   re_node_set_init_empty (dfa->edests + dfa->nodes_len);
--- origsrc/sed-4.2.2/lib/regex_internal.h	2012-12-22 14:21:52.000000000 +0100
+++ src/sed-4.2.2/lib/regex_internal.h	2013-06-27 18:05:27.230447242 +0200
@@ -1,22 +1,21 @@
-/* -*- buffer-read-only: t -*- vi: set ro: */
-/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
 /* Extended regular expression matching and search library.
-   Copyright (C) 2002-2012 Free Software Foundation, Inc.
+   Copyright (C) 2002-2013 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Isamu Hasegawa <isamu@yamato.ibm.com>.
 
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3, or (at your option)
-   any later version.
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
 
-   This program is distributed in the hope that it will be useful,
+   The GNU C Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
 
-   You should have received a copy of the GNU General Public License along
-   with this program; if not, see <http://www.gnu.org/licenses/>.  */
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
 
 #ifndef _REGEX_INTERNAL_H
 #define _REGEX_INTERNAL_H 1
@@ -28,21 +27,54 @@
 #include <string.h>
 
 #include <langinfo.h>
-#ifndef _LIBC
-# include "localcharset.h"
-#endif
 #include <locale.h>
 #include <wchar.h>
 #include <wctype.h>
 #include <stdbool.h>
 #include <stdint.h>
-#if defined _LIBC
+
+#ifdef _LIBC
 # include <bits/libc-lock.h>
+# define lock_define(name) __libc_lock_define (, name)
+# define lock_init(lock) (__libc_lock_init (lock), 0)
+# define lock_fini(lock) 0
+# define lock_lock(lock) __libc_lock_lock (lock)
+# define lock_unlock(lock) __libc_lock_unlock (lock)
+#elif defined GNULIB_LOCK
+# include "glthread/lock.h"
+  /* Use gl_lock_define if empty macro arguments are known to work.
+     Otherwise, fall back on less-portable substitutes.  */
+# if ((defined __GNUC__ && !defined __STRICT_ANSI__) \
+      || (defined __STDC_VERSION__ && 199901L <= __STDC_VERSION__))
+#  define lock_define(name) gl_lock_define (, name)
+# elif USE_POSIX_THREADS
+#  define lock_define(name) pthread_mutex_t name;
+# elif USE_PTH_THREADS
+#  define lock_define(name) pth_mutex_t name;
+# elif USE_SOLARIS_THREADS
+#  define lock_define(name) mutex_t name;
+# elif USE_WINDOWS_THREADS
+#  define lock_define(name) gl_lock_t name;
+# else
+#  define lock_define(name)
+# endif
+# define lock_init(lock) glthread_lock_init (&(lock))
+# define lock_fini(lock) glthread_lock_destroy (&(lock))
+# define lock_lock(lock) glthread_lock_lock (&(lock))
+# define lock_unlock(lock) glthread_lock_unlock (&(lock))
+#elif defined GNULIB_PTHREAD
+# include <pthread.h>
+# define lock_define(name) pthread_mutex_t name;
+# define lock_init(lock) pthread_mutex_init (&(lock), 0)
+# define lock_fini(lock) pthread_mutex_destroy (&(lock))
+# define lock_lock(lock) pthread_mutex_lock (&(lock))
+# define lock_unlock(lock) pthread_mutex_unlock (&(lock))
 #else
-# define __libc_lock_define(CLASS,NAME)
-# define __libc_lock_init(NAME) do { } while (0)
-# define __libc_lock_lock(NAME) do { } while (0)
-# define __libc_lock_unlock(NAME) do { } while (0)
+# define lock_define(name)
+# define lock_init(lock) 0
+# define lock_fini(lock) 0
+# define lock_lock(lock) ((void) 0)
+# define lock_unlock(lock) ((void) 0)
 #endif
 
 /* In case that the system doesn't have isblank().  */
@@ -65,7 +97,7 @@
 # ifdef _LIBC
 #  undef gettext
 #  define gettext(msgid) \
-  INTUSE(__dcgettext) (_libc_intl_domainname, msgid, LC_MESSAGES)
+  __dcgettext (_libc_intl_domainname, msgid, LC_MESSAGES)
 # endif
 #else
 # define gettext(msgid) (msgid)
@@ -101,6 +133,8 @@
 
 /* Rename to standard API for using out of glibc.  */
 #ifndef _LIBC
+# undef __wctype
+# undef __iswctype
 # define __wctype wctype
 # define __iswctype iswctype
 # define __btowc btowc
@@ -110,10 +144,8 @@
 # define attribute_hidden
 #endif /* not _LIBC */
 
-#if __GNUC__ >= 4 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1)
-# define __attribute(arg) __attribute__ (arg)
-#else
-# define __attribute(arg)
+#if __GNUC__ < 3 + (__GNUC_MINOR__ < 1)
+# define __attribute__(arg)
 #endif
 
 typedef __re_idx_t Idx;
@@ -429,7 +461,7 @@ static void build_upper_buffer (re_strin
 static void re_string_translate_buffer (re_string_t *pstr) internal_function;
 static unsigned int re_string_context_at (const re_string_t *input, Idx idx,
 					  int eflags)
-     internal_function __attribute ((pure));
+     internal_function __attribute__ ((pure));
 #endif
 #define re_string_peek_byte(pstr, offset) \
   ((pstr)->mbs[(pstr)->cur_idx + offset])
@@ -448,7 +480,9 @@ static unsigned int re_string_context_at
 #define re_string_skip_bytes(pstr,idx) ((pstr)->cur_idx += (idx))
 #define re_string_set_index(pstr,idx) ((pstr)->cur_idx = (idx))
 
-#include <alloca.h>
+#if defined _LIBC || HAVE_ALLOCA
+# include <alloca.h>
+#endif
 
 #ifndef _LIBC
 # if HAVE_ALLOCA
@@ -465,6 +499,12 @@ static unsigned int re_string_context_at
 # endif
 #endif
 
+#ifdef _LIBC
+# define MALLOC_0_IS_NONNULL 1
+#elif !defined MALLOC_0_IS_NONNULL
+# define MALLOC_0_IS_NONNULL 0
+#endif
+
 #ifndef MAX
 # define MAX(a,b) ((a) < (b) ? (b) : (a))
 #endif
@@ -695,7 +735,7 @@ struct re_dfa_t
 #ifdef DEBUG
   char* re_str;
 #endif
-  __libc_lock_define (, lock)
+  lock_define (lock)
 };
 
 #define re_node_set_init_empty(set) memset (set, '\0', sizeof (re_node_set))
@@ -767,7 +807,7 @@ bitset_copy (bitset_t dest, const bitset
   memcpy (dest, src, sizeof (bitset_t));
 }
 
-static void
+static void __attribute__ ((unused))
 bitset_not (bitset_t set)
 {
   int bitset_i;
@@ -779,7 +819,7 @@ bitset_not (bitset_t set)
        & ~set[BITSET_WORDS - 1]);
 }
 
-static void
+static void __attribute__ ((unused))
 bitset_merge (bitset_t dest, const bitset_t src)
 {
   int bitset_i;
@@ -787,7 +827,7 @@ bitset_merge (bitset_t dest, const bitse
     dest[bitset_i] |= src[bitset_i];
 }
 
-static void
+static void __attribute__ ((unused))
 bitset_mask (bitset_t dest, const bitset_t src)
 {
   int bitset_i;
@@ -798,7 +838,7 @@ bitset_mask (bitset_t dest, const bitset
 #ifdef RE_ENABLE_I18N
 /* Functions for re_string.  */
 static int
-internal_function __attribute ((pure))
+internal_function __attribute__ ((pure, unused))
 re_string_char_size_at (const re_string_t *pstr, Idx idx)
 {
   int byte_idx;
@@ -811,7 +851,7 @@ re_string_char_size_at (const re_string_
 }
 
 static wint_t
-internal_function __attribute ((pure))
+internal_function __attribute__ ((pure, unused))
 re_string_wchar_at (const re_string_t *pstr, Idx idx)
 {
   if (pstr->mb_cur_max == 1)
@@ -821,7 +861,7 @@ re_string_wchar_at (const re_string_t *p
 
 # ifndef NOT_IN_libc
 static int
-internal_function __attribute ((pure))
+internal_function __attribute__ ((pure, unused))
 re_string_elem_size_at (const re_string_t *pstr, Idx idx)
 {
 #  ifdef _LIBC
--- origsrc/sed-4.2.2/lib/regexec.c	2012-12-22 14:21:52.000000000 +0100
+++ src/sed-4.2.2/lib/regexec.c	2013-06-27 18:05:27.268447078 +0200
@@ -1,22 +1,21 @@
-/* -*- buffer-read-only: t -*- vi: set ro: */
-/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
 /* Extended regular expression matching and search library.
-   Copyright (C) 2002-2012 Free Software Foundation, Inc.
+   Copyright (C) 2002-2013 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Isamu Hasegawa <isamu@yamato.ibm.com>.
 
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3, or (at your option)
-   any later version.
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
 
-   This program is distributed in the hope that it will be useful,
+   The GNU C Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
 
-   You should have received a copy of the GNU General Public License along
-   with this program; if not, see <http://www.gnu.org/licenses/>.  */
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
 
 static reg_errcode_t match_ctx_init (re_match_context_t *cache, int eflags,
 				     Idx n) internal_function;
@@ -200,7 +199,7 @@ static Idx group_nodes_into_DFAstates (c
 static bool check_node_accept (const re_match_context_t *mctx,
 			       const re_token_t *node, Idx idx)
      internal_function;
-static reg_errcode_t extend_buffers (re_match_context_t *mctx)
+static reg_errcode_t extend_buffers (re_match_context_t *mctx, int min_len)
      internal_function;
 
 /* Entry point for POSIX code.  */
@@ -229,9 +228,7 @@ regexec (preg, string, nmatch, pmatch, e
 {
   reg_errcode_t err;
   Idx start, length;
-#ifdef _LIBC
   re_dfa_t *dfa = preg->buffer;
-#endif
 
   if (eflags & ~(REG_NOTBOL | REG_NOTEOL | REG_STARTEND))
     return REG_BADPAT;
@@ -247,14 +244,14 @@ regexec (preg, string, nmatch, pmatch, e
       length = strlen (string);
     }
 
-  __libc_lock_lock (dfa->lock);
+  lock_lock (dfa->lock);
   if (preg->no_sub)
     err = re_search_internal (preg, string, length, start, length,
 			      length, 0, NULL, eflags);
   else
     err = re_search_internal (preg, string, length, start, length,
 			      length, nmatch, pmatch, eflags);
-  __libc_lock_unlock (dfa->lock);
+  lock_unlock (dfa->lock);
   return err != REG_NOERROR;
 }
 
@@ -422,9 +419,7 @@ re_search_stub (struct re_pattern_buffer
   Idx nregs;
   regoff_t rval;
   int eflags = 0;
-#ifdef _LIBC
   re_dfa_t *dfa = bufp->buffer;
-#endif
   Idx last_start = start + range;
 
   /* Check for out-of-range.  */
@@ -435,7 +430,7 @@ re_search_stub (struct re_pattern_buffer
   else if (BE (last_start < 0 || (range < 0 && start <= last_start), 0))
     last_start = 0;
 
-  __libc_lock_lock (dfa->lock);
+  lock_lock (dfa->lock);
 
   eflags |= (bufp->not_bol) ? REG_NOTBOL : 0;
   eflags |= (bufp->not_eol) ? REG_NOTEOL : 0;
@@ -499,7 +494,7 @@ re_search_stub (struct re_pattern_buffer
     }
   re_free (pmatch);
  out:
-  __libc_lock_unlock (dfa->lock);
+  lock_unlock (dfa->lock);
   return rval;
 }
 
@@ -1065,7 +1060,7 @@ prune_impossible_nodes (re_match_context
    since initial states may have constraints like "\<", "^", etc..  */
 
 static inline re_dfastate_t *
-__attribute ((always_inline)) internal_function
+__attribute__ ((always_inline)) internal_function
 acquire_init_state_context (reg_errcode_t *err, const re_match_context_t *mctx,
 			    Idx idx)
 {
@@ -1177,7 +1172,7 @@ check_matching (re_match_context_t *mctx
 	  || (BE (next_char_idx >= mctx->input.valid_len, 0)
 	      && mctx->input.valid_len < mctx->input.len))
 	{
-	  err = extend_buffers (mctx);
+	  err = extend_buffers (mctx, next_char_idx + 1);
 	  if (BE (err != REG_NOERROR, 0))
 	    {
 	      assert (err == REG_ESPACE);
@@ -1757,7 +1752,7 @@ clean_state_log_if_needed (re_match_cont
 	  && mctx->input.valid_len < mctx->input.len))
     {
       reg_errcode_t err;
-      err = extend_buffers (mctx);
+      err = extend_buffers (mctx, next_state_log_idx + 1);
       if (BE (err != REG_NOERROR, 0))
 	return err;
     }
@@ -2814,7 +2809,7 @@ get_subexp (re_match_context_t *mctx, Id
 		  if (bkref_str_off >= mctx->input.len)
 		    break;
 
-		  err = extend_buffers (mctx);
+		  err = extend_buffers (mctx, bkref_str_off + 1);
 		  if (BE (err != REG_NOERROR, 0))
 		    return err;
 
@@ -3937,6 +3932,7 @@ check_node_accept_bytes (const re_dfa_t
 		in_collseq = find_collation_sequence_value (pin, elem_len);
 	    }
 	  /* match with range expression?  */
+	  /* FIXME: Implement rational ranges here, too.  */
 	  for (i = 0; i < cset->nranges; ++i)
 	    if (cset->range_starts[i] <= in_collseq
 		&& in_collseq <= cset->range_ends[i])
@@ -3988,18 +3984,9 @@ check_node_accept_bytes (const re_dfa_t
 # endif /* _LIBC */
 	{
 	  /* match with range expression?  */
-#if __GNUC__ >= 2 && ! (__STDC_VERSION__ < 199901L && defined __STRICT_ANSI__)
-	  wchar_t cmp_buf[] = {L'\0', L'\0', wc, L'\0', L'\0', L'\0'};
-#else
-	  wchar_t cmp_buf[] = {L'\0', L'\0', L'\0', L'\0', L'\0', L'\0'};
-	  cmp_buf[2] = wc;
-#endif
 	  for (i = 0; i < cset->nranges; ++i)
 	    {
-	      cmp_buf[0] = cset->range_starts[i];
-	      cmp_buf[4] = cset->range_ends[i];
-	      if (wcscoll (cmp_buf, cmp_buf + 2) <= 0
-		  && wcscoll (cmp_buf + 2, cmp_buf + 4) <= 0)
+	      if (cset->range_starts[i] <= wc && wc <= cset->range_ends[i])
 		{
 		  match_len = char_len;
 		  goto check_node_accept_bytes_match;
@@ -4137,7 +4124,7 @@ check_node_accept (const re_match_contex
 
 static reg_errcode_t
 internal_function __attribute_warn_unused_result__
-extend_buffers (re_match_context_t *mctx)
+extend_buffers (re_match_context_t *mctx, int min_len)
 {
   reg_errcode_t ret;
   re_string_t *pstr = &mctx->input;
@@ -4147,8 +4134,10 @@ extend_buffers (re_match_context_t *mctx
           <= pstr->bufs_len, 0))
     return REG_ESPACE;
 
-  /* Double the lengths of the buffers.  */
-  ret = re_string_realloc_buffers (pstr, MIN (pstr->len, pstr->bufs_len * 2));
+  /* Double the lengths of the buffers, but allocate at least MIN_LEN.  */
+  ret = re_string_realloc_buffers (pstr,
+				   MAX (min_len,
+					MIN (pstr->len, pstr->bufs_len * 2)));
   if (BE (ret != REG_NOERROR, 0))
     return ret;
 
--- origsrc/sed-4.2.2/sed/sed.c	2012-03-16 10:13:31.000000000 +0100
+++ src/sed-4.2.2/sed/sed.c	2013-06-27 18:06:25.592195456 +0200
@@ -57,7 +57,11 @@ bool follow_symlinks = false;
 char *in_place_extension = NULL;
 
 /* The mode to use to read/write files, either "r"/"w" or "rb"/"wb".  */
+#ifdef HAVE_FOPEN_RT
+char *read_mode = "rt";
+#else
 char *read_mode = "r";
+#endif
 char *write_mode = "w";
 
 /* Do we need to be pedantically POSIX compliant? */
