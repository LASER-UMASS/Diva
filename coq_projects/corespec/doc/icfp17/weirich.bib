%% BIBTEX %%


@article{breitner:safe-coercions-jfp,
title = "Safe zero-cost coercions for Haskell",
publisher = "Cambridge University Press",
address = "Cambridge, UK",
author = "Joachim Breitner and Richard A. Eisenberg and Simon Peyton Jones and
Stephanie Weirich",
volume = "26",
year = "2016",
month = "007",
day = "28",
plclub = "yes",
  pdf =       "http://www.seas.upenn.edu/~sweirich/papers/coercible-JFP.pdf",
abstract = "AbstractGenerative type abstractions – present in Haskell, OCaml, and other languages – are useful concepts to help prevent programmer errors. They serve to create new types that are distinct at compile time but share a run-time representation with some base type. We present a new mechanism that allows for zero-cost conversions between generative type abstractions and their representations, even when such types are deeply nested. We prove type safety in the presence of these conversions and have implemented our work in GHC.",
url = "https://www.cambridge.org/core/article/safe-zero-cost-coercions-for-haskell/FFB002A34C6B40EF150B5F357AA865DC",
journal = "Journal of Functional Programming"
}



@InProceedings{keuchel:infragen,
  author = 	  {Steven Keuchel and Stephanie Weirich and Thomas Tom Schrijvers},
  title = 	  {InfraGen: Binder Boilerplate at Scale},
  booktitle = {European Symposium on Programming (ESOP)},
  month = 	  apr,
  pages =     {419-445},
  year = 	  2016}

@InProceedings{type-app,
  author = 	  {Richard A. Eisenberg and Stephanie Weirich and Hamidhasan G. Ahmed},
  title = 	  {Visible Type Application},
  booktitle = {European Symposium on Programming (ESOP)},
  pdf =       {http://www.seas.upenn.edu/~sweirich/papers/esop2016-typeapp.pdf},
  month = 	  apr,
  pages =     {229-254},
  year = 	  2016}

@misc{type-app-extened,
  author = 	  {Richard A. Eisenberg and Stephanie Weirich and Hamidhasan G. Ahmed},
  title = 	  {Visible Type Application (Extended version)},
  pdf =       {http://www.seas.upenn.edu/~sweirich/papers/esop2016-typeapp-extended.pdf},
  month = 	  jan,
  year = 	  2016}


@InCollection{pj:reflection-types,
  author = {Simon {Peyton Jones} and Stephanie Weirich and Richard A. Eisenberg and
             Dimitrios Vytiniotis},
  title = {A Reflection on Types},
  booktitle = {WadlerFest 2016: A list of successes that can change the world},
  editor = {Sam Lindley and Conor McBride and Phil Trinder and Don Sannella},
  year = 2016,
  publisher = {Springer},
  pages = {292-317},
  series = {LNCS},
  pdf = "http://www.seas.upenn.edu/~sweirich/papers/wadlerfest2016.pdf"}
}

@InProceedings{rsgen,
  author = 		  {Wenrui Meng and Junkil Park and Oleg Sokolsky and
                  Stephanie Weirich and Insup Lee},
  title = 		  {Verified ROS-Based Deployment of Platform-Independent Control Systems},
  booktitle =    {Seventh {NASA} Formal Methods Symposium},
  address =      {Pasadena, CA},
  mon =          apr,
  pages = {248-262},
  pdf =          "http://repository.upenn.edu/cis_papers/794/",
  year = 	     2015}



@InProceedings{sjoberg:congruence,
  author = 	  {Vilhelm Sj\"oberg and Stephanie Weirich},
  title = 	  {Programming up to Congruence},
  booktitle = {POPL 2015: 42nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  month = 	  jan,
  year = 	  2015,
  address =   {Mumbai, India},
  plclub =    {yes},
  pages =     {369--382},
  pdf =       "http://www.seas.upenn.edu/~sweirich/papers/popl15-congruence.pdf",
}

@TechReport{sjoberg:congruence-extended,
  author = 		  {Vilhelm Sj\"oberg and Stephanie Weirich},
  title = 		  {Programming up to Congruence (Extended Version)},
  year = 		  2014,
  institution =  {University of Pennsylvania},
  number =       {MS-CIS-14-10},
  month = 	     oct,
  pdf =          "http://repository.upenn.edu/cis_reports/992/"
}

@InProceedings{breitner:safe-coercions,
  author = 	  {Joachim Breitner and Richard A. Eisenberg and Simon {Peyton Jones} and Stephanie Weirich},
  title = 	  {Safe Zero-Cost Coercions for {Haskell}},
  booktitle = {The 19th ACM SIGPLAN International Conference on Functional Programming},
  year = 	  2014,
  pages =     {189--202},
  series = 	  {ICFP '14},
  month = 	  sep,
  plclub = {yes},
  pdf =          "http://www.seas.upenn.edu/~sweirich/papers/coercible.pdf"
}


@TechReport{breitner:safe-coercions-extended,
  author = 		  {Joachim Breitner and Richard A. Eisenberg and Simon {Peyton Jones} and Stephanie Weirich},
  title = 		  {Safe Zero-cost Coercions for {Haskell} (Extended Version)},
  institution =  {Univ. of Pennsylvania},
  year = 		  2014,
  month =        apr,
  number = 	     {MS-CIS-14-07},
  pdf =          "http://www.seas.upenn.edu/~sweirich/papers/coercible-extended.pdf"
}


@InProceedings{eisenberg:closed-tf,
  author = 	  {Richard A. Eisenberg and Dimitrios Vytiniotis and Simon {Peyton Jones} and Stephanie Weirich},
  title = 	  {Closed type families with overlapping equations},
  booktitle = {POPL 2014: 41st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  year = 	  2014,
  month =     jan,
  pages =     {671--683},
  address =   {San Diego, CA, USA},
  plclub =    {yes},
  pdf =       "http://www.seas.upenn.edu/~sweirich/papers/popl14-axioms.pdf",
  extended =  "http://www.seas.upenn.edu/~sweirich/papers/popl14-axioms-extended.pdf"
}



@InProceedings{casinghino:combining-proofs-programs,
  author = 	  {Chris Casinghino and Vilhelm Sj\"oberg and Stephanie Weirich},
  title = 	  {Combining Proofs and Programs in a Dependently Typed Language},
  booktitle = {POPL 2014: 41st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  year = 	  2014,
  address =   {San Diego, CA, USA},
  pages =     {33--45},
  plclub =    {yes},
  pdf =       "http://www.seas.upenn.edu/~sweirich/papers/popl14-trellys.pdf",
  extended =  "http://www.seas.upenn.edu/~sweirich/papers/popl14-trellys-long.pdf"
}

@TechReport{casinghino:combining-proofs-extended,
  author = 	  {Chris Casinghino and Vilhelm Sj\"oberg and Stephanie Weirich},
  title = 	  {Combining Proofs and Programs in a Dependently Typed Language (With Technical Appendix)},
  year =      2013,
  institution = "University of Pennsylvania",
  pdf =       "http://repository.upenn.edu/cis_reports/985/",
  month =     nov,
  number =    {MS-CIS-13-08}
}

@TechReport{eisenberg:closed-tf-extended,
  author = 	  {Richard A. Eisenberg and Dimitrios Vytiniotis and Simon {Peyton Jones} and Stephanie Weirich},
  title = 	  {Closed type families with overlapping equations (Extended version)},
  year = 	  2013,
  month =     nov,
  plclub =    {yes},
  pdf =       "http://repository.upenn.edu/cis_reports/990/",
  institution = {University of Pennsylvania},
  number =    {MS-CIS-13-10}
}

@InProceedings{weirich:dwk,
  author = 	  {Stephanie Weirich and Justin Hsu and Richard A. Eisenberg},
  title = 	  {System {FC} with explicit kind equality},
  booktitle = {Proceedings of The 18th ACM SIGPLAN International Conference on Functional Programming},
  year = 	  2013,
  series = 	  {ICFP '13},
  address =   {Boston, MA},
  pages =     {275--286},
  plclub =    {yes},
  month =     sep,
  pdf =       "http://www.seas.upenn.edu/~sweirich/papers/fckinds.pdf"
}

@Misc{weirich:dwk-extended,
  author = 	  {Stephanie Weirich and Justin Hsu and Richard A. Eisenberg},
  title = 	  {System {FC} with explicit kind equality (Extended Version)},
  year = 	  2013,
  month =     sep,
  pdf =       "http://www.seas.upenn.edu/~sweirich/papers/fckinds-extended.pdf"
}



@InCollection{weirich:handbook,
  author = 	  {Stephanie Weirich},
   editor    = {Teofilo F. Gonzalez and
               Jorge Diaz-Herrera and
               Allen Tucker},
  booktitle =    {Computing Handbook, 3rd ed. (1)},
  title = 	     {Type Systems},
  pages =        {70:1--39},
  publisher = 	  {CRC Press},
  year = 		  2014,
  isbn      =    {978-1-43-989852-9}
}


@Misc{weirich:oplss2,
  author = 	  {Stephanie Weirich},
  title = 	  {Designing Dependently-Typed Programming Languages},
  howpublished = {Lectures given at the {Summer School on Logic and Theorem Proving
in Programming Languages}, Eugene OR, USA. July 2013},
  month =     jul,
  year = 	  2013
}

@misc{pii13preface,
  author = {Zhengjiang Hu and Shin-Cheng Mu and Stephanie Weirich},
  title = {Advanced programming techniques for construction of robust, generic and evolutionary programs},
  journal = {Progress in Informatics},
  number = 10,
  year = 2013,
  month = mar,
  pages = {1--2},
  plclub = {yes},
  url = {http://www.nii.ac.jp/pi/}
}

@article{pii13kimmel,
  author = {
Garrin Kimmel and Aaron Stump and Harley D. Eades and Peng Fu and Tim Sheard and Stephanie
Weirich and Chris Casinghino and Vilhelm Sj\"{o}berg and Nathin Collins and Ki Yunh Anh},
  title = {Equational reasoning about programs with general recursion and call-by-value
semantics},
  journal = {Progress in Informatics},
  number = 10,
  year = 2013,
  month = mar,
  pages = { 19--48},
  plclub = {yes},
  url = {http://www.nii.ac.jp/pi/}
}



@inproceedings{sparcs,
 author = {Pajic, Miroslav and Bezzo, Nicola and Weimer, James and Alur, Rajeev and Mangharam, Rahul and Michael, Nathan and Pappas, George J. and Sokolsky, Oleg and Tabuada, Paulo and Weirich, Stephanie and Lee, Insup},
 title = {Towards synthesis of platform-aware attack-resilient control systems: extended abstract},
 booktitle = {HiCoNS '13: Proceedings of the 2nd ACM international conference on High confidence networked systems},
 year = {2013},
 isbn = {978-1-4503-1961-4},
 pages = {75--76},
 location = {Philadelphia, Pennsylvania, USA},
 address = {New York, NY, USA},
 plclub = {yes}
 }

@misc{DBLP:journals/jar/PierceW12,
  author    = {Benjamin C. Pierce and
               Stephanie Weirich},
  title     = {Preface},
  journal   = {J. Autom. Reasoning},
  volume    = {49},
  number    = {3},
  year      = {2012},
  pages     = {301-302},
  ee        = {http://dx.doi.org/10.1007/s10817-012-9254-5},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  plclub    = {yes}
}

@misc{plmw12,
  author = 	  {Kathleen Fisher and Ronald Garcia and Stephanie Weirich},
  title = 	  {Nourishing the future of the field: the programming language mentoring workshop 2012},
  booktitle =    {ACM SIGPLAN Notices - Supplemental issue},
  journal =      {SIGPLAN Not.},
  month = 	  {April},
  year = 	  2012,
  volume = 47,
  number = {4a},
  issue_date = {April 2012},
  issue_description = {Supplemental issue},
  publisher = {ACM},
  address = {New York, NY, USA},
  doi =   {10.1145/2442776.2448985},
  pages = {14--15},
  plclub = {yes}
}

@misc{DBLP:journals/jfp/AcarCW12,
  author    = {Umut A. Acar and
               James Cheney and
               Stephanie Weirich},
  title     = {Editorial - Special issue dedicated to {ICFP 2010}},
  journal   = {J. Funct. Program.},
  volume    = {22},
  number    = {4-5},
  year      = {2012},
  pages     = {379-381},
  ee        = {http://dx.doi.org/10.1017/S0956796812000287},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  plclub    = {yes}
}

@article{greenberg:jfp,
  author    = {Michael Greenberg and
               Benjamin C. Pierce and
               Stephanie Weirich},
  title     = {Contracts made manifest},
  journal   = {Journal of Functional Programming},
  volume    = {22},
  number    = {3},
  month     = {May},
  year      = {2012},
  pages     = {225-274},
  ee        = {http://dx.doi.org/10.1017/S0956796812000135},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  plclub    = {yes}
}


@Misc{weirich:flops12,
  author = "Stephanie Weirich",
  title  = "Dependently typed programming in GHC",
  note = "Invited talk given at FLOPS 2012",
  slides = "http://www.seas.upenn.edu/~sweirich/talks/flops2012.pdf",
  month = "May",
  year = 2012,
  plclub = {yes}
}

@Misc{weirich:tlca11,
  author = "Stephanie Weirich",
  title = "Combining Proofs and Programs",
  note = "Joint invited speaker for Rewriting Techniques and Applications (RTA 2011) and Typed Lambda Calculi and Applications (TLCA 2011)",
  slides = "http://www.seas.upenn.edu/~sweirich/talks/tlca-2011.pdf",
  month = jun,
  year = 2011,
  plclub = {yes}
}

@inproceedings{eisenberg:singletons,
  author = 		  {Richard A. Eisenberg and Stephanie Weirich},
  title = 		  {Dependently typed programming with singletons},
  booktitle = {Haskell Symposium},
  month = 	  sep,
  year = 	  2012,
  pages =   {117--130},
  address = {Copenhagen, Denmark},
  project = "http://www.cis.upenn.edu/~eir/packages/singletons/",
  pdf = "http://www.seas.upenn.edu/~sweirich/papers/haskell12.pdf"
}

@Misc{weirich:oplss,
  author = 	  {Stephanie Weirich and Brian Aydemir},
  title = 	  {Coq for Programming Language Metatheory},
  howpublished = {Lectures given at the {Summer School on Logic and Theorem Proving
in Programming Languages}, Eugene OR, USA. July 22-25, 2008},
  year = 	  2008,
  note = {Tutorial materials available at \url{http://www.cis.upenn.edu/~plclub/oregon08/}}
}

@Misc{weirich:popl-tutorial,
  author = 	  {Brian Aydemir and Aaron Bohannon and Benjamin Pierce and Jeffrey Vaughan and Dimitrios Vytiniotis and Stephanie Weirich and Steve Zdancewic},
  title = 	  {Using Proof Assistants for Programming Language Research or, How to write your Next
POPL paper in Coq},
  howpublished = {Tutorial session co-located with POPL 2008, San Francisco, CA},
  month = 	  jan,
  year = 	  2008,
  note = 	  {Tutorial materials available at \url{http://www.cis.upenn.edu/~plclub/popl08-tutorial/}}}

@inproceedings{ccasin:msfp12,
  author = {Chris Casinghino and Vilhelm Sj\"{o}berg and Stephanie Weirich},
  title = {Step-Indexed Normalization for a Language with General Recursion},
  booktitle = {Fourth workshop on Mathematically Structured Functional Programming (MSFP '12)},
  year = 2012,
  pages = {25--39},
  pdf = {papers/msfp12log.pdf},
  plclub = {yes}
}

@inproceedings{sjoberg:msfp12,
  author = {Vilhelm Sj\"oberg and Chris Casinghino and Ki Yung Ahn and
            Nathan Collins and Harley D. Eades III and Peng Fu
            and Garrin Kimmell and Tim Sheard and Aaron Stump
            and Stephanie Weirich},
  title = {Irrelevance, Heterogenous Equality, and Call-by-value Dependent Type Systems},
  booktitle = {Fourth workshop on Mathematically Structured Functional Programming (MSFP '12)},
  year = 2012,
  pages = {112--162},
  plclub = {yes},
  pdf = {papers/msfp12prog.pdf}
}


@InProceedings{kimmel:plpv,
  author = 		  {Garrin Kimmell and Aaron Stump and Harley D. Eades III and
                 Peng Fu and Tim Sheard and Stephanie Weirich and Chris Casinghino
                 and Vilhelm Sj\"oberg and Nathan Collins and Ki Yung Ahn},
  title = 		  {Equational Reasoning about Programs with General Recursion and Call-by-value Semantics},
  booktitle = {Sixth ACM SIGPLAN Workshop Programming Languages meets Program Verification (PLPV '12)},
  year = 	  2012,
  plclub = "yes",
  pages = {15--26},
  pdf = {papers/plpv2012genreccbv.pdf}
}

@InProceedings{weirich:lifting,
  author = 		  {Brent A. Yorgey and Stephanie Weirich and
                  Julien Cretin and Simon {Peyton Jones} and
                  Dimitrios Vytiniotis and Jos\'{e} Pedro {Magalha\~{e}s}},
  title = 		  {Giving {Haskell} A Promotion},
  booktitle = {Seventh ACM SIGPLAN Workshop on Types in Language Design and Implementation (TLDI '12)},
  year = 	  2012,
  pdf =       "http://www.seas.upenn.edu/~sweirich/papers/tldi12.pdf",
  pages = {53--66},
  plclub = {yes}

}


@InProceedings{weirich:binders,
  author = 		  {Stephanie Weirich and Brent A. Yorgey and Tim Sheard},
  title = 		  {Binders Unbound},
  pdf =          "http://www.seas.upenn.edu/~sweirich/papers/icfp11.pdf",
  booktitle = {Proceeding of the 16th ACM SIGPLAN International Conference on Functional Programming},
 series = {ICFP '11},
 year = {2011},
 isbn = {978-1-4503-0865-6},
 location = {Tokyo, Japan},
 pages = {333--345},
 numpages = {13},
 acmid = {2034818},
 address = {New York, NY, USA},
 keywords = {generic programming, haskell, name binding, patterns},
 plclub = {yes}
}

@InProceedings{stump:position,
  author = 		  {Tim Sheard and Aaron Stump and Stephanie Weirich},
  title = 		  {Language-Based Verification Will Change The World},
  booktitle =    {2010 FSE/SDP Workshop on the Future of Software Engineering Research},
  year = 	  2010,
  month =     nov,
  plclub =    {yes},
  pages =     {343--348},
  pdf =       "http://www.seas.upenn.edu/~sweirich/papers/foser10.pdf",
  note = 	  {Position paper.}
}



@InProceedings{weirich:newtypes,
  author = 		  {Stephanie Weirich and Dimitrios Vytiniotis and Simon {Peyton Jones}
  and Steve Zdancewic},
  title = 		  {Generative Type Abstraction and Type-level Computation},
  booktitle = {POPL 11: 38th {ACM SIGACT-SIGPLAN} Symposium on Principles of Programming Languages, January 26--28, 2011. Austin, TX, USA.},
  year = 	  2011,
  pages =     {227--240},
  month =     jan,
  plclub =    {yes},
  pdf = "http://www.seas.upenn.edu/~sweirich/papers/popl163af-weirich.pdf",
  abstract =  "Modular languages support generative type abstraction,
ensuring that an abstract type is distinct from its
representation, except inside the implementation where the
two are synonymous.  We show that this well-established
feature is in tension with the non-parametric features
of newer type systems, such as indexed type families and GADTs.
In this paper we solve the problem by using kinds to
distinguish between parametric and non-parametric contexts.
The result is directly applicable to Haskell, which is rapidly
developing support for type-level computation, but the same
issues should arise whenever generativity and non-parametric features
are combined."
}

@TechReport{weirich:newtypes-long,
  author = 	 {Stephanie Weirich and Dimitrios Vytiniotis and Simon {Peyton Jones}
  and Steve Zdancewic},
  title = 	 {Generative Type Abstraction and Type-level Computation (Extended Version) },
  month = 	 nov,
  year = 	 2010,
  pdf = "http://www.cis.upenn.edu/~sweirich/papers/newtypes.pdf",
  abstract = "Modular languages support generative type abstraction,
ensuring that an abstract type is distinct from its
representation, except inside the implementation where the
two are synonymous.  We show that this well-established
feature is in tension with the non-parametric features
of newer type systems, such as indexed type families and GADTs.
In this paper we solve the problem by using kinds to
distinguish between parametric and non-parametric contexts.
The result is directly applicable to Haskell, which is rapidly
developing support for type-level computation, but the same
issues should arise whenever generativity and non-parametric features
are combined."
}

@proceedings{Haskell09,
  title = {Haskell Symposium},
  editor = {Stephanie Weirich},
  publisher = {ACM Press},
  year = {2009},
  month = aug,
  location = {Edinburgh, Scotland, August 2009},
  plclub = {Yes}
}

@misc{Weirich:Haskell09ChairsReport,
  author = {Stephanie Weirich},
  title = {Haskell 2009 PC Chair's Report},
  month = aug,
  year = {2009},
  plclub = {Yes}
}

@proceedings{ICFP10,
  title = {International Conference on Functional Programming},
  editor = {Stephanie Weirich},
  publisher = {ACM Press},
  year = {2010},
  month = sep,
  location = {Baltimore, MD, September 2010},
  plclub = {Yes}
}

@misc{Weirich:ICFP10ChairsReport,
  author = {Stephanie Weirich},
  title = {ICFP 2010 PC Chair's Report},
  month = sep,
  year = {2010},
  plclub = {Yes}
}



@InProceedings{teqt,
  author = 	 {Aaron Stump and Vilhelm Sj\"{o}berg and Stephanie Weirich},
  title = 	 {Termination Casts: A Flexible Approach to Termination with
General Recursion},
  booktitle = {Workshop on Partiality and Recursion in Interactive Theorem Provers},
  year = 	 2010,
  address = 	 {Edinburgh, Scotland},
  plclub =       {yes},
  pages =    {76--93},
  month = 	 jul,
  pdf =          "http://www.seas.upenn.edu/~sweirich/papers/submitted-PAR-10-Proceedings.pdf",
  abstract = "
This paper proposes a type-and-effect system that
distinguishes terminating terms and total functions from possibly
diverging terms and partial functions, for a lambda calculus with
general recursion and equality types.  The central idea is to include
a primitive type-form ``Terminates t'', expressing that term t is
terminating; and then allow terms t to be coerced from possibly
diverging to total, using a proof of Terminates t.  We call such
coercions \emph{termination casts}, and show how to implement
terminating recursion using them.  For the meta-theory of the system,
we describe a translation from this system to a logical theory of
termination for general recursive, simply typed functions.  Every
typing judgment of this system is translated to a theorem expressing the
appropriate termination property of the computational part of the
term."
}



@TechReport{teqt-tr,
  author = 		  {Aaron Stump and Vilhelm Sj\"oberg and Stephanie Weirich},
  title = 		  {Termination Casts: A Flexible Approach to Termination with General Recursion (Technical Appendix)},
  institution =  {University of Pennsylvania Department of Computer and Information Science},
  year = 		  2010,
  pdf =          {http://repository.upenn.edu/cis_reports/930/},
  number = 	  {MS-CIS-10-21}}


@InProceedings{contracts,
  author = 	 {Michael Greenberg and Benjamin Pierce and Stephanie Weirich},
  title = 	 {Contracts Made Manifest},
  booktitle = 	 {37th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages (POPL)},
  year =	 2010,
  address =	 {Madrid, Spain},
  month =	 jan,
  pages =        { 353--364 },
  pdf =          "http://www.seas.upenn.edu/~sweirich/papers/popl10-greenberg.pdf",
  project =      "http://www.seas.upenn.edu/~mgree/papers/lambdah_parred.tgz",
  abstract = "
Since Findler and Felleisen introduced higher-order contracts, many
variants have been proposed.  Broadly, these fall into two groups:
some follow Findler and Felleisen in using latent contracts, purely
dynamic checks that are transparent to the type system; others use
manifest contracts, where refinement types record the most recent
check that has been applied to each value.  These two approaches are
commonly assumed to be equivalent---different ways of implementing the
same idea, one retaining a simple type system, and the other providing
more static information.  Our goal is to formalize and clarify this
folklore understanding.

Our work extends that of Gronski and Flanagan, who defined a latent
calculus lambdac and a manifest calculus lambdah, gave a translation
phi from lambdac to lambdah, and proved that, if a lambdac term
reduces to a constant, then so does its phiimage.  We enrich their
account with a translation psi from lambdah to lambdac and prove an
analogous theorem.

We then generalize the whole framework to dependent contracts, whose
predicates can mention free variables.  This extension is both
pragmatically crucial, supporting a much more interesting range of
contracts, and theoretically challenging.  We define dependent
versions of lambdah and two dialects (``lax'' and ``picky'') of
lambdac, establish type soundness---a substantial result in itself,
for lambdah---and extend phi and psi accordingly.  Surprisingly, the
intuition that the latent and manifest systems are equivalent now
breaks down: the extended translations preserve behavior in one
direction but, in the other, sometimes yield terms that blame more.  "

}

@InProceedings{iseq,
  author = 	 {Limin Jia and Jianzhou Zhao and Vilhem Sj\"{o}berg and Stephanie Weirich},
  title = 	 {Dependent types and Program Equivalence},
  booktitle = 	 {37th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages (POPL)},
  year =	 2010,
  address =	 {Madrid, Spain},
  month =	 jan,
  plclub =       {yes},
  pages =        {275--286},
  pdf =          "http://www.seas.upenn.edu/~sweirich/papers/popl10-lambda-eek.pdf",
  project =      {http://www.cis.upenn.edu/~plclub/lambda-eek},
  abstract =
"The definition of type equivalence is one of the most important design
issues for any typed language. In dependently-typed languages, because
terms appear in types, this definition must rely on a definition of
term equivalence. In that case, decidability of type checking requires
decidability for the term equivalence relation.

Almost all dependently-typed languages require this relation to be
decidable. Some, such as Coq, Epigram or Agda, do so by employing
analyses to force all programs to terminate. Conversely, others, such
as DML, ATS, Omega, or Haskell, allow nonterminating computation, but
do not allow those terms to appear in types. Instead, they identify a
terminating index language and use singleton types to connect indices
to computation. In both cases, decidable type checking comes at a
cost, in terms of complexity and expressiveness.

Conversely, the benefits to be gained by decidable type checking are
modest. Termination analyses allow dependently typed programs to
verify total correctness properties. However, decidable type checking
is not a prerequisite for type safety.  Furthermore, decidability does
not imply tractability. A decidable approximation of program
equivalence may not be useful in practice.

Therefore, we take a different approach: instead of a fixed notion for
term equi valence, we parameterize our type system with an abstract
relation that is not n ecessarily decidable. We then design a novel
set of typing rules that require on ly weak properties of this
abstract relation in the proof of the preservation an d progress
lemmas. This design provides flexibility: we compare valid instantiat
ions of term equivalence which range from beta-equivalence, to
contextual equiva lence, to some exotic equivalences.
"
}

@inproceedings{bohannon:firescript,
  author = 		  {Aaron Bohannon and Benjamin C. Pierce and Vilhelm Sj\"oberg and Stephanie Weirich and Steve Zdancewic},
  title = 		  {Reactive Noninterference},
  booktitle =             {16th ACM Conference on Computer and Communications Security},
  month =		  nov,
  year =	          2009,
  pages =                 {79--90},
  plclub =               {no},
  pdf =                  "http://www.seas.upenn.edu/~sweirich/papers/csf09-draft.pdf",
  abstract = "Many programs operate reactively---patiently waiting for user input, running
for a while producing output, and eventually returning to a state where they
are ready to accept another input (or occasionally diverging).  When a
reactive program communicates with multiple parties, we would like to be
sure that it can be given secret information by one without leaking it to
others.

Motivated by web browsers and client-side web applications,
we explore definitions of noninterference for reactive programs and
identify two of special interest---one corresponding to
termination-insensitive noninterference for a simple sequential language,
the other to termination-sensitive noninterference.  We focus on the former
and develop a proof technique for showing that program behaviors are secure
according to this definition.  To demonstrate the viability of the approach,
we define a simple reactive language with an information-flow type system
and apply our proof technique to show that well-typed programs are secure.
"
}


@Article{vytiniotis:romega,
  author = 		  {Dimitrios Vytiniotis and Stephanie Weirich},
  title = 		  {Parametricity, Type Equality and Higher-order Polymorphism},
  journal = 	  "Journal of Functional Programming",
  year =	 	     2010,
  month =        mar,
  volume =       20,
  number =       2,
  pages =        {175--210},
  plclub =       {yes},
  pdf =          {http://www.cis.upenn.edu/~sweirich/papers/gparam-jfp2.pdf},
  abstract = {
  Propositions that express type equality are a frequent ingredient of
  modern functional programming---they can encode generic
  functions, dynamic types, and GADTs. Via the Curry-Howard
  correspondence, these propositions are ordinary types
  inhabited by proof terms, computed using runtime type
  representations. In this paper we show that two examples of type
  equality propositions actually do reflect type equality; they are
  only inhabited when their arguments are equal and their proofs are
  unique (up to contextual equivalence.)  We show this result in the
  context of a strongly normalizing language with higher-order
  polymorphism and primitive recursion over runtime type
  representations by proving Reynolds's abstraction theorem. We then
  use this theorem to derive ``free'' theorems about equality types.
}
}


@misc{vytiniotis:romega-draft,
  author = 		  {Dimitrios Vytiniotis and Stephanie Weirich},
  title = 		  {Type-safe cast does no harm: Syntactic parametricity for F-omega and beyond},
  note = 		  {Submitted for publication},
  month =		  mar,
  year =			  2009,
  pdf =          {http://www.cis.upenn.edu/~sweirich/papers/gparam-jfp.pdf},
  abstract =     {
Generic functions can specialize their behaviour depending on the
types of their arguments, and can even recurse over the structure of
the types of their arguments.  Such functions can be programmed
using type representations.  Generic functions
programmed this way possess certain parametricity properties, which
become interesting in the presence of higher-order polymorphism.
In this Theoretical Pearl, we give a rigorous roadmap through the
proof of parametricity for a calculus with higher-order polymorphism
and type representations. We then use parametricity to derive the
partial correctness of type-safe cast.
  }
}

@InCollection{weirich:aritygen-journal,
  author = 	  {Stephanie Weirich and Chris Casinghino},
  editor = 	  {Jeremy Gibbons},
  booktitle =        {Generic and Indexed Programming},
  title = 	  {Generic Programming with Dependent Types},
  publisher = 	  {Springer-Verlag Berlin Heidelberg},
  year = 		  2012,
  pdf =          {http://www.cis.upenn.edu/~sweirich/papers/ssgip-journal.pdf},
  number = 	  7470,
  series = 	  "Lecture Notes in Computer Science",
  plclub =    "yes",
  pages = 	  {217--258}}

@InProceedings{aritygen,
  author = 	 {Stephanie Weirich and Chris Casinghino},
  title = 	 {Arity-generic type-generic programming},
  booktitle =    {{ACM SIGPLAN} Workshop on Programming Languages Meets Program Verification (PLPV)},
  pages =        {15--26},
  month =	 jan,
  plclub =       {yes},
  year =	 2010,
  pdf  =         "http://www.seas.upenn.edu/~sweirich/papers/aritygen.pdf"
}

@TechReport{aydemir:lngen,
  title =        {{LNgen}: Tool Support for Locally Nameless Representations},
  author =       {Brian Aydemir and Stephanie Weirich},
  institution =  {Computer and Information Science, University of Pennsylvania},
  month =        jun,
  year =	        2010,
  plclub =       {yes},
  number =       {MS-CIS-10-24},
  pdf =          {http://repository.upenn.edu/cis_reports/933},
  pdf =          "http://www.seas.upenn.edu/~sweirich/papers/MS-CIS-10-24.pdf",
  projecturl =   {http://www.cis.upenn.edu/~sweirich/papers/lngen/}
}

@TechReport{aydemir:syntax,
  author = 		  {Brian Aydemir and Steve Zdancewic and Stephanie Weirich},
  title = 		  {Abstracting Syntax},
  number =       {MS-CIS-09-06},
  month =        mar,
  year =	  2009,
  plclub =       {no},
  institution =  {Computer and Information Science, University of Pennsylvania},
  pdf =          {http://repository.upenn.edu/cis_reports/901/},
  projecturl =   "http://www.cis.upenn.edu/~sweirich/papers/abstracting-syntax/"
}


@InProceedings{vytiniotis:fph,
  author = 		  {Dimitrios Vytiniotis and Stephanie Weirich and Simon Peyton Jones},
  title = 		  {{FPH:} First-class polymorphism for {Haskell}},
  booktitle = 	  {ICFP 2008: The 13th ACM SIGPLAN International Conference on Functional Programming },
  year =			  2008,
  address =		  {Victoria, BC, Canada},
  month =		  sep,
  plclub =       "yes",
  pages = {295--306},
  pdf =          "http://www.seas.upenn.edu/~sweirich/papers/icfp08.pdf",
  abstract =  "Languages supporting polymorphism typically have ad-hoc restrictions
on where polymorphic types may occur.  Supporting ``first-class'' polymorphism,
by lifting those restrictions, is obviously desirable, but it is hard
to achieve this without sacrificing type inference.  We present a new
type system for higher-rank and impredicative polymorphism that improves
on earlier proposals: it is an extension of Damas-Milner;
it relies only on System F types; it has a simple, declarative specification;
it is robust to program transformations; and it enjoys a complete and decidable
type inference algorithm.
"
}




@misc{washburn08:seckinds,
  author = 		  {Geoffrey Washburn and Stephanie Weirich},
  title = 		  {Generalizing Parametricity Using Information Flow},
  journal = 	  {Logical Methods in Computer Science},
  year = 		  2008,
  month =        mar,
  note =			  {Submitted for publication. 47 pages},
  pdf =          "http://www.seas.upenn.edu/~sweirich/papers/lmcs-seckind.pdf",
  plclub = {no}
}

@InProceedings{aydemir:popl-binders,
  author = 		  {Brian Aydemir and Arthur Chargu\'{e}raud and Benjamin C. Pierce and Randy Pollack and Stephanie Weirich},
  title = 		  {Engineering Formal Metatheory},
  booktitle =    {{ACM} {SIGPLAN}-{SIGACT} Symposium on Principles of Programming Languages (POPL)},
  month =		  jan,
  year =			  2008,
  pages =        {3--15},
  pdf =          {http://repository.upenn.edu/cis_papers/369},
  plclub =       {no},
  projecturl =   {http://www.chargueraud.org/arthur/research/2007/binders/},
  abstract =     {
Machine-checked proofs of properties of programming languages have become a
critical need, both for increased confidence in large and complex designs
and as a foundation for technologies such as proof-carrying code.  However,
constructing these proofs remains a black art, involving many choices in the
formulation of definitions and theorems that make a huge cumulative
difference in the difficulty of carrying out large formal developments.  The
representation and manipulation of  terms with variable binding is a
key issue.

We propose a novel style for formalizing metatheory, combining
locally nameless representation of terms and
cofinite quantification of free variable names in inductive
definitions of relations on terms (typing, reduction, \ldots).  The
key technical insight is that our use of cofinite quantification
obviates the need for reasoning about equivariance (the fact that free
names can be renamed in derivations); in particular, the structural
induction principles of relations defined using cofinite
quantification are strong enough for metatheoretic reasoning, and
need not be explicitly strengthened.
Strong inversion principles follow (automatically, in Coq) from the
induction principles.  Although many of the underlying ingredients of
our technique have been used before, their combination here yields a
significant improvement over existing methodology, leading to
developments that are faithful to informal practice, yet require no
external tool support and little infrastructure within the proof
assistant.

We have carried out several large developments in this style using the Coq
proof assistant and have made them publicly available. Our developments
include type soundness for \SystemFsub and ML (with references, exceptions,
datatypes, recursion and patterns) and subject reduction for the Calculus of
Constructions. Not only do these developments demonstrate the
comprehensiveness of our approach; they have also been optimized for clarity
and robustness, making them good templates for future extension.
}
}


@misc{char:binders,
  author =		  {Arthur Chargu\'eraud and Benjamin Pierce and Stephanie Weirich},
  title =		  {Proof Engineering: Practical Techniques for Mechanized Metatheory},
  month =		  sep,
  year =			  2006,
}

@InProceedings{vytiniotis07a,
  author = 		  {Dimitrios Vytiniotis and Stephanie Weirich},
  title = 		  {Dependent types: Easy as {PIE}},
  booktitle = 	  {Draft Proceedings of the 8th Symposium on Trends in Functional Programming},
  pages =		  {XVII-1---XVII-15},
  year =			  2007,
  editor =		  {Marco T. Moraz\'{a}n and Henrik Nilsson},
  month =		  apr,
  organization = {Dept. of Math and Computer Science, Seton Hall University},
  note =			  {TR-SHU-CS-2007-04-1},
  pdf =  "http://www.seas.upenn.edu/~sweirich/papers/tfp07.pdf",
  plclub = {yes}
}

@misc{aydemir07,
  author = 		  {Brian Aydemir and Arthur Chargu\'{e}raud and Benjamin C. Pierce and Stephanie Weirich},
  title = 		  {Engineering Aspects of Formal Metatheory},
  note = 		  {Draft},
  month =		  apr,
  year =			  2007,
  pdf = {http://www.cis.upenn.edu/~bcpierce/papers/binders.pdf},
  plclub = {no},
  projecturl = {http://www.chargueraud.org/arthur/research/2007/binders/},
  abstract = {
Machine-checked proofs of the properties of programming languages have
become a critical need, both for increasing confidence in large and complex
designs and as a foundation for technologies such as proof-carrying code.
However, constructing these proofs remains a black art, involving many
choices in the formulation of basic definitions that are commonly elided in
informal arguments but that make a huge cumulative difference in the
difficulty of carrying out large developments formally.

To clarify these basic choices, we have constructed \emph{reference
formalizations} in Coq of type soundness for several core programming
languages---the simply-typed lambda calculus, System F-sub, and
mini-ML---and subject-reduction for the Calculus of Constructions. No
single aspect of these formalizations is especially novel; our goal,
rather, has been to assemble a good set of mutually supporting design
choices, together with a small number of powerful tactics to make
proofs in this domain as smooth and natural as possible.  Key features
include a locally nameless representation for syntax with binders, a
formulation of the ``local closure'' predicate that leads to a natural
induction principle for terms, and a treatment of variable freshness
using universal quantification over a cofinite set of names.  } }


@InProceedings{vytiniotis:parametricity,
  author = 		  {Dimitrios Vytiniotis and Stephanie Weirich},
  title = 		  {Free theorems and runtime type representations},
  booktitle =    {Mathematical Foundations of Programming Semantics (MFPS XXIII)},
  month =		  apr,
  year =			  2007,
  pages = {357--373},
  address =      {New Orleans, LA, USA},
  plclub =       {yes},
  pdf =          "http://www.seas.upenn.edu/~sweirich/papers/rtheorems07.pdf",
  ps =          "http://www.seas.upenn.edu/~sweirich/papers/rtheorems07.ps",
  abstract =     {
    Reynolds' abstraction theorem, often referred to
  as the parametricity theorem, can be used to derive properties about
  functional programs solely from their types. Unfortunately, in the
  presence of runtime type analysis, the abstraction properties of
  polymorphic programs are no longer valid. However, runtime type
  analysis can be implemented with term-level representations of
  types, as in the  language of Crary et
    al., where case analysis on
  these runtime representations introduces type refinement. In this
  paper, we show that representation-based analysis is consistent with
  type abstraction by extending the abstraction theorem to such a
  language. We also discuss the ``free theorems'' that result.  This
  work provides a foundation for the more general problem of extending
  the abstraction theorem to languages with generalized algebraic
  datatypes.
}
}

@article{dantas:aspectml-journal,
  author = 		  {Daniel S. Dantas and David Walker and Geoffrey Washburn and Stephanie Weirich},
  title = 		  {{AspectML}: A Polymorphic Aspect-oriented Functional Programming Language},
  journal =      {ACM Transactions on Programming Languages},
  year =         {2008},
  month =         may,
  volume =       {30},
  pages =        {1--60},
  number = {3},
  issn = {0164-0925},
  address = {New York, NY, USA},
  pdf =          {http://repository.upenn.edu/cis_papers/379},
  projecturl = {http://www.cs.princeton.edu/sip/projects/aspectml/},
  abstract = {
This paper defines Aspectml, a typed functional, aspect-oriented
programming language. The main contribution of Aspectml is the
seamless integration of polymorphism, run-time type analysis
and aspect-oriented programming language features. In particular,
Aspectml allows programmers to define type-safe polymorphic advice
using pointcuts constructed from a collection of polymorphic join
points. Aspectml also comes equipped with a type inference algorithm
that conservatively extends Hindley-Milner type inference. To support
first-class polymorphic point-cut designators, a crucial feature for
developing aspect-oriented profiling or logging libraries, the
algorithm blends the conventional Hindley-Milner type inference
algorithm with a simple form of local type inference.

We give our language operational meaning via a type-directed
translation into an expressive type-safe intermediate language. Many
complexities of the source language are eliminated in this
translation, leading to a modular specification of its semantics. One
of the novelties of the intermediate language is the definition of
polymorphic labels for marking control-flow points. These labels are
organized in a tree structure such that a parent in the tree serves as
a representative for all of its children. Type safety requires that
the type of each child is less polymorphic than its parent
type. Similarly, when a set of labels is assembled as a pointcut, the
type of each label is an instance of the type of the pointcut.
  }
}

@InProceedings{aydemir:nominal-coq,
  author = 		  {Brian Aydemir and Aaron Bohannon and Stephanie Weirich},
  title = 		  {Nominal Reasoning Techniques in {Coq}},
  booktitle = 	  {International Workshop on Logical Frameworks and
                  Meta-Languages:Theory and Practice (LFMTP) },
  year =			  2006,
  address =		  {Seattle, WA, USA},
  month =		  aug,
  pdf =          "http://www.seas.upenn.edu/~sweirich/papers/nominal-coq/lfmtp06.pdf",
  projecturl =   "http://www.seas.upenn.edu/~sweirich/papers/nominal-coq/",
  plclub =       {yes},
  pages = { 60--69},
  abstract = {
  We explore an axiomatized nominal approach to variable binding in Coq,
  using an untyped lambda-calculus as our test case.  In our nominal
  approach, alpha-equality of lambda terms coincides with Coq's built-in
  equality.  Our axiomatization includes a nominal induction principle and
  functions for calculating free variables and substitution.  These axioms
  are collected in a module signature and proved sound
  using locally nameless terms as the underlying
  representation.  Our experiences so far suggests that it is feasible to
  work from such axiomatized theories in Coq and that the nominal style of
  variable binding corresponds closely with paper proofs.  We are currently
  working on proving the soundness of a primitive recursion combinator
  and developing a method of generating these axioms and their proof of
  soundness from a grammar describing the syntax of terms and binding.
  }
}

@TechReport{InCertProposal07,
  title = {Manifest Security},
  author = {Karl Crary and  Robert Harper and Frank Pfenning and
                  Benjamin C. Pierce and Stephanie Weirich and
                  Stephan Zdancewic},
  year = 2007,
  month = JAN,
  keys = {security},
  plclub = {No},
  note = {White paper},
  pdf = {http://www.cis.upenn.edu/~bcpierce/papers/manifestsecurity-whitepaper.pdf}
}

@misc{InCertProposal06,
  TITLE = {Manifest Security for Distributed Information},
  AUTHOR = {Karl Crary and  Robert Harper and Frank Pfenning and
                  Benjamin C. Pierce and Stephanie Weirich and
                  Stephan Zdancewic},
  YEAR = 2006,
  MONTH = MAR,
  KEYS = {security},
  NOTE = {White paper},
  PDF = {http://www.cis.upenn.edu/~bcpierce/papers/incertproposal06.pdf}
}

@inproceedings{weirich:replib,
  author = 		  {Stephanie Weirich},
  title = 		  {{RepLib}: {A} library for derivable type classes},
  booktitle =    {Haskell Workshop},
  month =		  sep,
  address =      {Portland, OR, USA},
  year =			  2006,
  plclub =       {yes},
  pages =        "1--12",
  pdf =          {http://repository.upenn.edu/cis_papers/362},
  projecturl      =     {http://www.seas.upenn.edu/~sweirich/RepLib/},
  abstract =     {
  Some type class instances can be automatically derived from the
  structure of types. As a result, the Haskell language includes the
  "deriving" mechanism to automatic generates such instances for a
  small number of built-in type classes. In this paper, we present
  RepLib, a GHC library that enables a similar mechanism for arbitrary
  type classes. Users of RepLib can define the relationship between
  the structure of a datatype and the associated instance declaration
  by a normal Haskell functions that pattern-matches a representation
  types. Furthermore, operations defined in this manner are
  extensible---instances for specific types not defined by type
  structure may also be incorporated. Finally, this library also
  supports the definition of operations defined by parameterized
  types.
  }
}

@inproceedings{washburn:good-advice,
  author = 		  {Geoffrey Washburn and Stephanie Weirich},
  title = 		  {Good Advice for Type-directed Programming:
      {A}spect-oriented Programming and Extensible Generic Functions},
  month =		  sep,
  plclub =       {yes},
  year = 	  2006,
  pdf  =      "http://www.seas.upenn.edu/~sweirich/papers/aspect-tdp.pdf",
  projecturl = {http://www.cs.princeton.edu/sip/projects/aspectml/},
  booktitle =     {Workshop on Generic Programming (WGP)},
  address = {Portland, OR, USA},
  pages = {33--44},
  abstract = {
Type-directed programming is an important idiom for software design.
In type-directed programming the behavior of programs is guided by the
type structure of data.  It makes it possible to implement many sorts
of operations, such as serialization, traversals, and queries, only
once and without needing to continually revise their implementation as
new data types are defined.

Type-directed programming is the basis for recent research into
"scrapping" tedious boilerplate code that arises in functional
programming with algebraic data types.  This research has primarily
focused on writing type-directed functions that are closed to
extension. However, L\"ammel and Peyton Jones recently developed a
technique for writing openly extensible type-directed functions in
Haskell by making clever use of type classes.  Unfortunately, this
technique has a number of limitations.

We present an alternate approach to writing openly extensible
type-directed functions by using the aspect-oriented programming
features provided by the language AspectML.  Our solution not only
avoids the limitations present in L\"ammel and Peyton Jones technique,
but also allows type-directed functions to be extended at any time
with cases for types that were not even known at compile-time.  This
capability is critical to writing programs that make use of dynamic
loading or runtime type generativity.
}
}

@InProceedings{pierce:position,
  author = 		  {Benjamin C. Pierce and Peter Sewell and
                  Stephanie Weirich and Steve Zdancewic},
  title = 		  {It is Time to Mechanize Programming Language Metatheory},
  booktitle = 	  {Verified Software: Theories, Tools, Experiments (VS:TTE)},
  year =			  2005,
  pages =        {26--30},
  address =		  {Z\"urich, Switzerland},
  month =		  oct,
  annote =			  {This position paper is adapted from the introduction
                  to the {\sc POPLMark} Challenge paper~\cite{mmm}.},
  pdf = {http://vstte.ethz.ch/Files/pierce-sewell-weirich-zdancewic.pdf},
  projecturl = {http://fling-l.seas.upenn.edu/~plclub/cgi-bin/poplmark/index.php?title=The_POPLmark_Challenge},
  abstract = {

How close are we to a world in which mechanically verified software is
commonplace? A world in which theorem proving technology is used
routinely by both software developers and programming
language researchers alike? One crucial step towards achieving these
goals is mechanized reasoning about language metatheory. The time has
come to bring together the theorem proving and programming language
communities to address this problem. We have proposed the POPLMark
challenge as a concrete set of benchmarks intended both for measuring
progress in this area and for stimulating discussion and
collaboration. Our goal is to push the boundaries of existing
technology to the point where we can achieve mechanized metatheory for
the masses.
 }
}

@InProceedings{vytiniotis:boxy,
  TOPIC = {language design},
  HISTORICAL = {The paper shows how type inference can exploit user annotations in order to type check programs
                that require first-class polymorphism. This revision of the boxy types paper offers a new smart-application rule,
                that outperforms the versions of smart-application appearing in earlier drafts.
                Many parts have been rewritten and clarified.},
  TITLE = {Boxy type inference for higher-rank types and impredicativity},
  booktitle = {International Conference on Functional Programming (ICFP)},
  ABSTRACT = {
               Languages with rich type systems are beginning to
               employ a blend of type inference and type
               checking, so that the type inference engine is
               guided by programmer-supplied type annotations.  In
               this paper we show, for the first time, how to combine
               the virtues of two well-established ideas:
               unification-based inference, and bidirectional
               propagation of type annotations.  The result is a type
               system that conservatively extends Hindley-Milner, and
               yet supports both higher-rank types and
               impredicativity. },
  AUTHOR = {Dimitrios Vytiniotis and Stephanie Weirich and Simon L. {Peyton Jones}},
  MONTH = sep,
  YEAR = 2006,
  PDF = {http://repository.upenn.edu/cis_papers/275/},
  projecturl = {http://www.cis.upenn.edu/%7Edimitriv/dimitriv-inference.html},
  CATEGORY = {fcp},
  address = {Portland, OR, USA},
  PLCLUB = {yes},
  pages = { 251--262}
}


@TECHREPORT{vytiniotis:boxy-techreport,
  TOPIC = {language design},
  AUTHOR = {Dimitrios Vytiniotis and Stephanie Weirich and Simon L. {Peyton~Jones}},
  TITLE = {Boxy type inference for higher-rank types and impredicativity, {Technical Appendix}},
  INSTITUTION = {University of Pennsylvania},
  YEAR = 2006,
  NUMBER = {MS-CIS-05-23},
  MONTH = {April},
  PDF = {http://www.cis.upenn.edu/~sweirich/boxy/boxy-techreport.pdf},
  CATEGORY = {fcp},
  CATTYPE = {report},
  HISTORICAL = {This report accompanies the boxy types paper and provides proofs for the claims in that paper.}
}

@InProceedings{pj-vytiniotis:wobbly,
  AUTHOR = {Simon L. {Peyton Jones} and Dimitrios Vytiniotis and Stephanie Weirich and Geoffrey Washburn},
  TITLE = {Simple unification-based type inference for {GADTs}},
  booktitle = {International Conference on Functional Programming (ICFP)},
  HISTORICAL = {This paper differs from previous versions of the ``wobbly types'' paper in that the ambiguity caused
                by unification is now recorded in the environments and typing judgements instead of the types. The most
                recent addition is the notion of the ``fresh most general unifier'', which eliminates problems arising from
                the directionality of arbitrary most general unifiers, when they are used for GADT type refinement.},
  ABSTRACT = {
               Generalized algebraic data types (GADTs), sometimes known as ``guarded
               recursive data types'' or ``first-class phantom
               types'', are a simple but powerful generalization of
               the data types of Haskell and ML.  Recent works have
               given compelling examples of the utility of GADTs,
               although type inference is known to be difficult.  Our
               contribution is to show how to exploit
               programmer-supplied type annotations to make the type
               inference task almost embarrassingly easy.  Our main
               technical innovation is wobbly types, which express in
               a declarative way the uncertainty caused by the
               incremental nature of typical type-inference
               algorithms. },
  MONTH = sep,
  YEAR = 2006,
  plclub = {yes},
  PDF = "http://www.seas.upenn.edu/~sweirich/papers/gadt/icfp06-gadt.pdf",
  CATEGORY = {gadt},
  address = {Portland, OR, USA},
  pages = {50--61}
}


@TECHREPORT{vytiniotis:gadt-techreport,
  TOPIC = {language design},
  AUTHOR = {Dimitrios Vytiniotis and Stephanie Weirich and Simon L. {Peyton~Jones}},
  TITLE = {Simple unification-based type inference for {GADTs}, {Technical Appendix}},
  INSTITUTION = {University of Pennsylvania},
  YEAR = 2006,
  NUMBER = {MS-CIS-05-22},
  MONTH = {April},
  CATEGORY = {gadt},
  CATTYPE = {report},
  plclub = "yes",
  PDF = {http://www.cis.upenn.edu/~sweirich/gadt/wobbly-techreport.pdf}
}



@InProceedings{dantas:polyaml,
  author = 		  {Daniel S. Dantas and David Walker and Geoffrey Washburn and Stephanie Weirich},
  title = 		  {{PolyAML}: A polymorphic aspect-oriented functional programmming language},
  booktitle =    "{ACM SIGPLAN} International Conference on Functional Programming (ICFP) ",
  pages =        {306-319},
  month =		  sep,
  year =			  2005,
  address =      {Tallinn, Estonia},
  PS =           "http://www.seas.upenn.edu/~sweirich/papers/poly/poly-aspect.ps",
  PDF =          "http://www.seas.upenn.edu/~sweirich/papers/poly/poly-aspect.pdf",
  projecturl = {http://www.cs.princeton.edu/sip/projects/aspectml/},
  abstract = {
This paper defines PolyAML, a typed functional and aspect-oriented
programming language.  The main contribution of PolyAML is in the
seamless integration of polymorphism, run-time type analysis and
aspect-oriented programming language features.  In particular, PolyAML
allows programmers to define type-safe polymorphic advice using pointcuts
constructed from a collection of polymorphic join points.  PolyAML
also comes equipped with a type inference algorithm that conservatively
extends Hindley-Milner type inference.  In order to support first-class
polymorphic point-cut designators, a crucial feature for developing
aspect-oriented profiling or logging libraries, the algorithm blends the
conventional Hindley-Milner type inference algorithm with a simple form
of local type inference.

We give our language operational meaning via a type-directed
translation into an expressive type-safe intermediate language.  Many
complexities of the source language are eliminated in this
translation, leading to a modular specification of its semantics.  One
of the novelties of the intermediate language is the definition of
polymorphic labels for marking control-flow points.  These labels are
organized in a tree structure such that a parent in the tree serves as
a representative for the collection of all its children.  Type safety
requires that the type of each child is a generic instance of the type
of the polymorphic parent.  Similarly, when a set of labels is
assembled as a pointcut, the type of each label is an instance of the
type of the pointcut.
}
}




@TechReport{dantas:tech-report,
  author = 		  {Daniel S. Dantas and David Walker and Geoffrey Washburn and Stephanie Weirich},
  title = 		  {{PolyAML:} A Polymorphic Aspect-Oriented Functional Programming Language (Extended Version)},
  institution =  {University of Pennsylvania, Department of Computer and Information Science},
  year = 		  2005,
  pdf =          {http://repository.upenn.edu/cis_reports/51/},
  number =		  {MS-CIS-05-07},
  abstract =     {
This paper defines PolyAML, a typed functional, aspect-oriented programming language. The main contribution of PolyAML is the seamless integration of polymorphism, run-time type analysis and aspect-oriented programming language features. In particular, PolyAML allows programmers to define type-safe polymorphic advice using pointcuts constructed from a collection of polymorphic join points. PolyAML also comes equipped with a type inference algorithm that conservatively extends Hindley-Milner type inference. To support first-class polymorphic point-cut designators, a crucial feature for developing aspect-oriented profiling or logging libraries, the algorithm blends the conventional Hindley-Milner type inference algorithm with a simple form of local type inference.

We give our language operational meaning via a type-directed translation into an expressive type-safe intermediate language. Many complexities of the source language are eliminated in this translation, leading to a modular specification of its semantics. One of the novelties of the intermediate language is the definition of polymorphic labels for marking control-flow points. These labels are organized in a tree structure such that a parent in the tree serves as a representative for all of its children. Type safety requires that the type of each child is less polymorphic than its parent type. Similarly, when a set of labels is assembled as a pointcut, the type of each label is an instance of the type of the pointcut.}

}

@article{peyton-jones:practical,
  author = 		  {Simon L. {Peyton Jones} and Dimitrios Vytiniotis and Stephanie Weirich and Mark Shields},
  title = 		  {Practical type inference for arbitrary-rank types},
  journal =      "Journal of Functional Programming",
  year =			  2007,
  plclub =       {yes},
  pages =        {1--82},
  volume =       17,
  number =       1,
  month =        jan,
  projecturl = {http://www.cis.upenn.edu/%7Edimitriv/dimitriv-inference.html},
  pdf = {http://repository.upenn.edu/cis_papers/315/},
  abstract =     {
Haskell's popularity has driven the need for ever more expressive type
system features, most of which threaten the decidability and
practicality of Damas-Milner type inference. One such feature is the
ability to write functions with higher-rank types --- that is,
functions that take polymorphic functions as their arguments.

Complete type inference is known to be undecidable for higher-rank
(impredicative) type systems, but in practice programmers are more
than willing to add type annotations to guide the type inference
engine, and to document their code. However, the choice of just what
annotations are required, and what changes are required in the type
system and its inference algorithm, has been an ongoing topic of
research.

We take as our starting point a lambda-calculus proposed by Odersky
and Laufer. Their system supports arbitrary-rank polymorphism through
the exploitation of type annotations on lambda-bound arguments and
arbitrary sub-terms. Though elegant, and more convenient than some
other proposals, Odersky and Laufer's system requires many
annotations. We show how to use local type inference (invented by
Pierce and Turner) to greatly reduce the annotation burden, to the
point where higher-rank types become eminently usable.

Higher-rank types have a very modest impact on type inference. We
substantiate this claim in a very concrete way, by presenting a
complete type-inference engine, written in Haskell, for a traditional
Damas-Milner type system, and then showing how to extend it for
higher-rank types. We write the type-inference engine using a monadic
framework: it turns out to be a particularly compelling example of
monads in action.

The paper is long, but is strongly tutorial in style.
  }
}


@TechReport{peyton-jones:practical-tr,
  author = 		  {Simon L. {Peyton Jones} and Dimitrios Vytiniotis and Stephanie Weirich and Mark Shields},
  title = 		  {Practical type inference for arbitrary-rank types (Technical appendix)},
  month =        jul,
  year =			  2005,
  institution =  {University of Pennsylvania},
  number =		  {MIS-CIS-05-14},
  projecturl = {http://www.cis.upenn.edu/%7Edimitriv/dimitriv-inference.html},
  pdf = "http://repository.upenn.edu/cis_reports/58/"
}

@InProceedings{mmm,
  author = 		  {Brian E. Aydemir and Aaron Bohannon and Matthew Fairbairn and J. Nathan Foster and Benjamin C. Pierce and Peter Sewell and Dimitrios Vytiniotis and Geoffrey Washburn and Stephanie Weirich and Steve Zdancewic},
  title = 		  {Mechanized Metatheory for the Masses: The {POPLmark} Challenge},
  booktitle = 	  {The 18th International Conference on Theorem Proving in Higher Order Logics (TPHOLs)},
  month =		  aug,
  year =			  2005,
  address =      {Oxford, UK},
  pages =        {50--65},
  projecturl =   {http://alliance.seas.upenn.edu/~plclub/cgi-bin/poplmark/index.php?title=The_POPLmark_Challenge},
  ps = {http://www.cis.upenn.edu/proj/plclub/mmm/poplmark/poplmark.ps},
  pdf = "http://repository.upenn.edu/cis_papers/235/",
  abstract = {How close are we to a world where every paper on
programming languages is accompanied by an electronic appendix with
machine-checked proofs?

We propose a concrete set of benchmarks for measuring progress in this
area.  Based on the metatheory of System F-sub, a typed
lambda-calculus with second-order polymorphism, subtyping, and
records, these benchmarks embody many aspects of programming languages
that are challenging to formalize: variable binding at both the term
and type levels, syntactic forms with variable numbers of components
(including binders), and proofs demanding complex induction
principles.  We hope that these benchmarks will help clarify the
current state of the art, provide a basis for comparing competing
technologies, and motivate further research.  }
}


@InProceedings{washburn:seckinds,
  author = 		  {Geoffrey Washburn and Stephanie Weirich},
  title = 		  {Generalizing Parametricity Using Information Flow},
  booktitle =    {Twentieth Annual IEEE Symposium on. Logic in Computer Science (LICS 2005)},
  year =			  2005,
  PAGES =        {62--71},
  month =        jun,
  address =      {Chicago, IL, USA},
  ps =           "http://www.seas.upenn.edu/~sweirich/papers/seckinds/lics2005.ps",
  pdf =          "http://repository.upenn.edu/cis_papers/220/",
  projecturl =   "http://www.seas.upenn.edu/%7Esweirich/tdj/tdj.htm",
  abstract = {Run-time type analysis allows programmers to easily and
concisely define many operations based upon type structure, such as
serialization, iterators, and structural equality.  However, when
types can be inspected at run time, nothing is secret.  A module
writer cannot use type abstraction to hide implementation details from
clients: those clients can use type analysis to determine the
structure of these supposedly ``abstract'' data types.  Furthermore,
access control mechanisms do not help in isolating the implementation
of abstract datatypes from their clients.  Buggy or malicious
authorized modules may simply leak type information to unauthorized
clients, so module implementors cannot reliably tell which parts of a
program rely on their type definitions and which parts do not.

Currently, module implementors rely on parametric polymorphism to
provide guarantees about the use of their abstract datatypes.
Standard type parametricity does not hold for a language with run-time
type analysis, but in this paper we show how to generalize the
statement of parametricity so that it does hold in the presence of
type analysis and still encompasses the integrity and confidentiality
policies that are normally derived from parametricity.  The key is to
augment the type system with annotations about information flow.
Because the type system tracks the flow of dynamic type information,
the implementor of an abstract data type can easily see what parts of
the program depend on the implementation of a given type.
} }

@TechReport{washburn:seckinds-tr,
  author = 		  {Geoffrey Washburn and Stephanie Weirich},
  title = 		  {Generalizing Parametricity Using Information Flow (Extended version)},
  number =       {MS-CIS-05-04},
  institution =  {Computer and Information Science, University of Pennsylvania},
  year =			  2005,
  month =        jul,
  pdf =          {http://repository.upenn.edu/cis_reports/50/},

  abstract = {Run-time type analysis allows programmers to easily and
concisely define many operations based upon type structure, such as
serialization, iterators, and structural equality.  However, when
types can be inspected at run time, nothing is secret.  A module
writer cannot use type abstraction to hide implementation details from
clients: those clients can use type analysis to determine the
structure of these supposedly ``abstract'' data types.  Furthermore,
access control mechanisms do not help in isolating the implementation
of abstract datatypes from their clients.  Buggy or malicious
authorized modules may simply leak type information to unauthorized
clients, so module implementors cannot reliably tell which parts of a
program rely on their type definitions and which parts do not.

Currently, module implementors rely on parametric polymorphism to
provide guarantees about the use of their abstract datatypes.
Standard type parametricity does not hold for a language with run-time
type analysis, but in this paper we show how to generalize the
statement of parametricity so that it does hold in the presence of
type analysis and still encompasses the integrity and confidentiality
policies that are normally derived from parametricity.  The key is to
augment the type system with annotations about information flow.
Because the type system tracks the flow of dynamic type information,
the implementor of an abstract data type can easily see what parts of
the program depend on the implementation of a given type.
} }

%%  note =         {15 pages},

@TechReport{peyton-jones:wobbly,
  author = 		  {Simon L. {Peyton Jones} and Geoffrey Washburn and
                 Stephanie Weirich},
  title = 		  {Wobbly types: Practical Type Inference for Generalised
                  Algebraic Dataypes},
  month =        jul,
  year =			  2004,
  number =       {MS-CIS-05-26},

  pdf =          {http://www.cis.upenn.edu/~sweirich/papers/gadt/MS-CIS-05-26.pdf},
 INSTITUTION =   {University of Pennsylvania, Computer and Information Science Department},
 ADDRESS = {Levine Hall,
             3330 Walnut Street, Philadelphia, Pennsylvania, 19104-6389},
abstract = {
Generalised algebraic data types (GADTs), sometimes known as ``guarded
recursive data types'' or ``first-class phantom types'', are a simple
but powerful generalisation of the data types of Haskell and ML.
Recent works have given compelling examples of the utility of GADTs,
although type inference is known to be difficult.

It is time to pluck the fruit.  Can GADTs be added to Haskell, without
losing type inference, or requiring unacceptably heavy type annotations?
Can this be done without completely rewriting the already-complex Haskell
type-inference engine, and without complex interactions with (say)
type classes?  We answer these questions in the affirmative, giving
a type system that explains just what type annotations are required,
and a prototype implementation that implements it.  Our main technical
innovation is \emph{wobbly types}, which express in a declarative way
the uncertainty caused by the incremental nature of typical type-inference
algorithms.
}
}

%% 25 pages
@misc{dantas:poly-aspects,
  author = 		  {Dan S. Dantas and David Walker and Geoffrey Washburn and
                  Stephanie Weirich},
  title = 		  {Analyzing Polymorphic Advice},
  month =		  oct,
  year =			  2004,
  projecturl = {http://www.cs.princeton.edu/sip/projects/aspectml/},
  pdf =          "http://www.cis.upenn.edu/~sweirich/papers/poly/poly-aspect.pdf",
  note =         {An extended version of this paper is Princeton University Computer
                  Science Technical Report TR-717-04}
}

%%   note = 		  {24 pages},
@TechReport{dantas:poly-aspects-tr,
  author = 		  {Dan S. Dantas and David Walker and Geoffrey Washburn and
                  Stephanie Weirich},
  title = 		  {Analyzing Polymorphic Advice},
  month =		  dec,
  institution =  {Princeton University Computer Science},
  number =       {TR-717-04},
  year =			  2004,
  pdf =          "http://ncstrl.cs.princeton.edu/expand.php?id=TR-717-04",
  projecturl = {http://www.cs.princeton.edu/sip/projects/aspectml/},

  abstract = { We take one of the first steps towards developing a
   practical, statically-typed, functional, aspect-oriented
   programming language by showing how to integrate polymorphism and
   type analysis with aspect-oriented programming features.  In
   particular, we demonstrate how to define type-safe polymorphic
   advice using pointcuts that unify a collection of polymorphic join
   points.  We also introduce a new mechanism for specifying
   context-sensitive advice that involves pattern matching against the
   current stack of activation records, and meshes well with
   functional programming idioms.  We give our language meaning via a
   type-directed translation into an expressive, but fairly simple,
   type-safe intermediate language.  Many complexities of the source
   language are eliminated in this translation, leading to a modular
   specification of its semantics.  One of the novelties of the
   intermediate language is the definition of polymorphic labels for
   marking control-flow points.  These labels are organized in a tree
   structure such that a parent in the tree serves as a representative
   for the collection of all its children.  Type safety requires that
   the type of each child is a generic instance of the type of the
   polymorphic parent.  Similarly, when a set of labels is assembled
   as a pointcut, the type of each label is an instance of the type of
   the pointcut.
  }
}

%% 64 pages
@article{washburn:bgb-journal,
  year =         {2008},
  author = 		  {Geoffrey Washburn and Stephanie Weirich},
  title = 		  {Boxes Go Bananas: {E}ncoding Higher-order
                  Abstract Syntax with Parametric Polymorphism},
  journal =      "Journal of Functional Programming",
  pages =        {87--140},
  month =        jan,
  volume =        18,
  number =       1,
  pdf =          "http://www.seas.upenn.edu/~sweirich/papers/bgb-jfp.pdf",
  abstract =     {
Higher-order abstract syntax is a simple technique for implementing
languages with functional programming. Object variables and binders
are implemented by variables and binders in the host language. By
using this technique, one can avoid implementing common and tricky
routines dealing with variables, such as capture-avoiding
substitution. However, despite the advantages this technique provides,
it is not commonly used because it is difficult to write sound
elimination forms (such as folds or catamorphisms) for
higherorder abstract syntax. To fold over such a datatype, one must
either simultaneously define an inverse operation (which may not
exist) or show that all functions embedded in the datatype are
parametric.

In this paper, we show how first-class polymorphism can be used to
guarantee the parametricity of functions embedded in higher-order
abstract syntax. With this restriction, we implement a library of
iteration operators over data-structures containing functionals. From
this implementation, we derive fusion laws that functional
programmers may use to reason about the iteration operator. Finally,
we show how this use of parametric polymorphism corresponds to the
Sch\"urmann, Despeyroux and Pfenning method of enforcing parametricity
through modal types. We do so by using this library to give a sound
and complete encoding of their calculus into System F-omega. This
encoding can serve as a starting point for reasoning about
higher-order structures in polymorphic languages.
  }
}

%% 20 pages
@InProceedings{weirich:tdj,
  plclub =       "yes",
  author = 		  {Stephanie Weirich and Liang Huang},
  title = 		  {A Design for Type-Directed {Java}},
  booktitle = 	  {Workshop on Object-Oriented Developments (WOOD)},
  year =			  2004,
  month =        aug,
  editor =		  {Viviana Bono},
  series =		  {ENTCS},
  pages =        {117-136},
  annote =       {An extended version of this paper is
                  University of Pennsylvania
                  Computer and Information Science Technical Report
                  MS-CIS-04-11.},
  projecturl =    "http://www.seas.upenn.edu/%7Esweirich/tdj/tdj.htm",
  pdf = "http://repository.upenn.edu/cis_papers/275/",
  ps = "http://www.cis.upenn.edu/~lhuang3/pubs/tdj-short.ps",

  abstract = {
  Type-directed programming is an important and widely used
  paradigm in the design of software. With this form of programming,
  an application may analyze type information to determine its
  behavior. By analyzing the structure of data, many operations, such
  as serialization, cloning, adaptors and iterators may be defined
  once, for all types of data. That way, as the program evolves, these
  operations need not be updated---they will automatically adapt to
  new data forms.  Otherwise, each of these operations must be
  individually redefined for each type of data, forcing programmers to
  revisit the same program logic many times during a program's
  lifetime.

  The Java language supports type directed programming with the
  instanceof operator and the Java Reflection API.  These
  mechanisms allow Java programs to depend on the name and structure
  of the run-time classes of objects.  However, the Java mechanisms
  for type-directed programming are difficult to use. They also do not
  integrate well with generics, an important new feature of the Java
  language.

  In this paper, we describe the design of several expressive new
  mechanisms for type-directed programming in Java, and show that
  these mechanisms are sound when included in a language similar to
  Featherweight Java. Basically, these new mechanisms pattern-match
  the name and structure of the type parameters of generic code,
  instead of the run-time classes of objects.  Therefore, they
  naturally integrate with generics and provide strong guarantees
  about program correctness. As these mechanisms are based on pattern
  matching, they naturally and succinctly express many operations that
  depend on type information. Finally, they provide programmers with
  some degree of protection for their abstractions. Whereas
  instanceof and reflection can determine the exact run-time type
  of an object, our mechanisms allow any supertype to be supplied for
  analysis, hiding its precise structure.}
}

@Article{weirich:cast-journal,
  plclub =       "yes",
  author = 		  {Stephanie Weirich},
  title = 		  {Type-Safe Cast},
  journal = 	  "Journal of Functional Programming",
  month =        nov,
  year = 		  2004,
  volume =       14,
  number =       6,
  pages =        {681-695},
  pdf =          {http://journals.cambridge.org/bin/bladerunner?REQUNIQ=1098990699&REQSESS=1422511&118000REQEVENT=&REQINT1=254715&REQAUTH=0},
  abstract =     {   Comparing two types for equality is an essential ingredient for an
  implementation of dynamic types. Once equality has been established,
  it is safe to cast a value from one type to another. In a language
  with run-time type analysis, implementing such a procedure is fairly
  straightforward.  Unfortunately, this naive implementation destructs
  and rebuilds the argument while iterating over its type structure.
  However, by using higher-order polymorphism, a casting function can
  treat its argument parametrically. We demonstrate this solution in
  two frameworks for ad-hoc polymorphism: intensional type analysis
  and Haskell type classes.}
}

%% 30 pages
%   pdf =          {http://journals.cambridge.org/action/displayFulltext?type=1&fid=409644&jid=JFP&volumeId=-1&issueId=-1&aid=409643},

@Article{weirich:erasure,
  author = 		  {Stephanie Weirich},
  title = 		  {Type-Safe Run-time Polytypic Programming},
  journal = 	  "Journal of Functional Programming",
  year = 		  2006,
  month =        nov,
  pages =        {681--710},
  plclub =       {yes},
  volume =       16,
  number =        10,
  pdf =          {http://www.seas.upenn.edu/~sweirich/papers/erasure/erasure-jfp.pdf},
  abstract =     {
  Polytypic programming is a way of defining type-indexed
  operations, such as map, fold and zip, based on type information.
  Run-time polytypic programming allows that type information to
  be dynamically computed---this support is essential in modern
  programming languages that support separate compilation, first-class
  type abstraction, or polymorphic recursion.

  However, in previous work we defined run-time polytypic programming
  with a type-passing semantics. Although it is natural to define
  polytypic programs as operating over first-class types, such a
  semantics suffers from a number of drawbacks. This paper describes
  how to recast that work in a type-erasure semantics, where terms
  represent type information in a safe manner.  The resulting language
  is simple and easy to implement---we present a prototype
  implementation of the necessary machinery as a small Haskell
  library.
  }
}

@TechReport{huang:tdp-tr,
  plclub =       "yes",
  author = 		  {Liang Huang and Stephanie Weirich},
  title = 		  {A Design for Type-Directed Programming in {Java} (Extended Version)},
  institution =  {University of Pennsylvania, Computer and Information Science},
  year = 		  2004,
  number =		  {MS-CIS-04-11},
  month =		  oct,
  pages =        {1--49},
  ps =           "http://www.seas.upenn.edu/~sweirich/papers/tdj/ms-cis-04-11.ps",
  pdf =          "http://www.seas.upenn.edu/~sweirich/papers/tdj/ms-cis-04-11.pdf"
}


@InProceedings{vytiniotis:itaname,
  author = 		  {Dimtrios Vytiniotis and Geoffrey Washburn and Stephanie Weirich},
  title = 		  {An Open and Shut Typecase},
  booktitle = 	  {{ACM SIGPLAN Workshop} on Types in Language Design and Implementation},
  year =			  2005,
  pages =        {13--24},
  address =		  {Long Beach, CA, USA},
  month =		  jan,
  annote =       {An extended version of this paper
                 is University of
                 Pennsylvania Technical Computer and Information Science
                 Report MS-CIS-04-26},
  ps =           "http://www.cis.upenn.edu/~sweirich/itaname/itaname.pdf",
  abstract =
{Two different ways of defining ad-hoc polymorphic operations commonly
occur in programming languages. With the first form polymorphic
operations are defined inductively on the structure of types while
with the second form polymorphic operations are defined for specific
sets of types.

In intensional type analysis operations are defined by induction on
the structure of types. Therefore no new cases are necessary for
user-defined types, because these types are equivalent to their
underlying structure.  However, intensional type analysis is
``closed'' to extension, as the behavior of the operations cannot be
differentiated for the new types, thus destroying the distinctions
that these types are designed to express.

Haskell type classes on the other hand define polymorphic operations
for sets of types. Operations defined by class instances are
considered ``open''---the programmer can add instances for new types
without modifying existing code. However, the operations must be
extended with specialized code for each new type, and it may be
tedious or even impossible to add extensions that apply to a large
universe of new types.

Both approaches have their benefits, so it is important to let
programmers decide which is most appropriate for their needs. In this
paper, we define a language that supports both forms of ad-hoc
polymorphism, using the same basic constructs.}

}

@TechReport{vytiniotis:itaname-tr,
  author = 		  {Dimtrios Vytiniotis and Geoffrey Washburn and Stephanie Weirich},
  title = 		  {An Open and Shut Typecase (Extended Version)},
  institution =  {University of Pennsylvania, Computer and Information Science},
  year = 		  2004,
  pages =        {1--50},
  number =		  {MS-CIS-04-26},
  month =		  oct,
  pdf =          {http://repository.upenn.edu/cis_reports/27/},
abstract =     {
Ad-hoc polymorphism is a compelling addition to typed programming languages. There are two different forms of ad-hoc polymorphism. With the nominal form, the execution of an operation is determined solely by the name of the type argument, whereas with the structural form, operations are defined by case analysis on the structure of types. The two forms differ in the way that they treat user-defined types. Operations defined by the nominal approach are considered "open"--the programmer can add cases for new types without modifying existing code. The operations must be extended however with specialized code for the new types, and it may be tedious and even difficult to add extensions that apply to a potentially large universe of user-defined types. Structurally defined operations apply to new types by treating them as equal to their underlying definitions, so no new cases for new types are necessary. However this form is considered "closed" to extension, as the behaviour of the operations cannot be differentiated for the new types. This form destroys the distinctions that user-defined types are designed to express. Both approaches have their benefits, so it is important to provide both capabilities in a single language that is expressive enough to decouple the "openness" issue from the way that user-defined types are treated. We present such a language that supports both forms of ad-hoc polymorphism.}
}
#  pdf =           "http://www.cis.upenn.edu/~sweirich/itaname/itaname-extended.pdf",


@misc{washburn:mtr,
  author = 		  {Geoffrey Washburn and Stephanie Weirich},
  title = 		  {Unifying nominal and structural ad-hoc
                  polymorphism (Extended version) },
  institution =  {University of Pennsylvania},
  year = 		  2004,
  month =		  mar,
  pdf = "http://www.cis.upenn.edu/~sweirich/papers/itaname/tech-report-mar04.pdf",

  abstract = "Ad-hoc polymorphism allows the execution of programs to
  depend on type information. In modern systems, it is useful for
  implementing generic operations over data structures, such as
  equality, marshalling, or traversal.  In the past, there have been
  two different forms of ad-hoc polymorphism. The nominal form
  dispatches on the name of the type argument, whereas the structural
  form operates by decomposing the structure of types. In languages
  with user-defined types, these two approaches are very
  different. Operations defined by the nominal approach are
  ``open''---they must be extended with specialized branches for
  user-defined types. In contrast, structurally defined operations are
  closed to extension. They automatically apply to user-defined types
  by treating them as their underlying definitions.  Both approaches
  have their benefits, so it important to provide both capabilities in
  a language. Therefore we present an expressive language that
  supports both forms of ad-hoc polymorphism in a single framework.
  Among the language's features are the ability to define both
  ``open'' and ``closed'' operations with a single mechanism, the
  ability to naturally restrict the domain of type-analyzing
  operations, and new mechanisms for defining higher-order polytypism
  and manipulating generative type definitions."  }

@misc{weirich:erasure-manuscript,
  author = 		  {Stephanie Weirich},
  title = 		  {Higher-Order Intensional Type Analysis in Type Erasure Semantics},
  note = 		  {At \url{http://www.cis.upenn.edu/~sweirich/papers/erasure/erasure-paper-july03.pdf}},
  month =		  jul,
  year =			  2003,
  ps =           "http://www.seas.upenn.edu/~sweirich/papers/erasure/erasure-paper-july03.ps",
  pdf =          "http://www.seas.upenn.edu/~sweirich/papers/erasure/erasure-paper-july03.pdf",
  abstract =     { Higher-order intensional type analysis is a way of defining
  type-indexed operations, such as map, fold and zip, based on
  run-time type information. However, languages supporting this
  facility are naturally defined with a type-passing semantics, which
  suffers from a number of drawbacks. This paper, describes how to
  recast higher-order intensional type analysis in a type-erasure
  semantics.  The resulting language is simple and easy to
  implement---we present a prototype implementation of the necessary
  machinery as a small Haskell library.}
}

@TechReport{washburn:itabox-tr,
  author = 		  {Geoffrey Washburn and Stephanie Weirich},
  title = 		  {Boxes Go Bananas: {E}ncoding Higher-order
                  Abstract Syntax with Parametric Polymorphism
                   (Extended version) },
  institution =  {University of Pennsylvania, Computer and Information Science },
  year = 		  2003,
  number =		  {MS-CIS-03-26},
  month =		  sep,
  ps =           "http://www.seas.upenn.edu/~sweirich/papers/itabox/MS-CIS-03-26.ps",
  pdf =          {http://repository.upenn.edu/cis_reports/43/},
  annote =       {This paper is an extended version of \cite{washburn:itabox}.},
  abstract =
{Higher-order abstract syntax is a simple technique for implementing languages with functional programming. Object variables and binders are implemented by variables and binders in the host language. By using this technique, one can avoid implementing common and tricky routines dealing with variables, such as capture-avoiding substitution. However, despite the advantages this technique provides, it is not commonly used because it is difficult to write sound elimination forms (such as folds or catamorphisms) for higher-order abstract syntax. To fold over such a datatype, one must either simultaneously define an inverse operation (which may not exist) or show that all functions embedded in the datatype are parametric.

In this paper, we show how first-class polymorphism can be used to guarantee the parametricity of functions embedded in higher-order abstract syntax. With this restriction, we implement a library of iteration operators over data-structures containing functionals. From this implementation, we derive "fusion laws" that functional programmers may use to reason about the iteration operator. Finally, we show how this use of parametric polymorphism corresponds to the Schuermann, Despeyroux and Pfenning method of enforcing parametricity through modal types. We do so by using this library to give a sound and complete encoding of their calculus into System F-omega. This encoding can serve as a starting point for reasoning about higher-order structures in polymorphic languages.}
}



%  note =         "An extended and revised version of this paper
%                 has been submitted for publication.",

@InProceedings{washburn:itabox,
  author = 		  {Geoffrey Washburn and Stephanie Weirich},
  title = 		  {Boxes Go Bananas: {E}ncoding Higher-order
                  Abstract Syntax with Parametric Polymorphism},
  booktitle =	  "{ACM SIGPLAN} International Conference on Functional Programming (ICFP) ",
  pages =		  {249--262},
  year =			  2003,
  address =		  {Uppsala, Sweden},
  month =		  aug,
  ps =           "http://www.seas.upenn.edu/~sweirich/papers/itabox/icfp-published-version.ps",
  pdf =          "http://www.seas.upenn.edu/~sweirich/papers/itabox/icfp-published-version.pdf",

  abstract = {Higher-order abstract syntax is a simple technique for
implementing languages with functional programming.  Object variables
and binders are implemented by variables and binders in the host
language.  By using this technique, one can avoid implementing common
and tricky routines dealing with variables, such as capture-avoiding
substitution.  However, despite the advantages this technique
provides, it is not commonly used because it is difficult to write
sound elimination forms (such as folds or catamorphisms) for
higher-order abstract syntax. To fold over such a datatype, one must
either simultaneously define an inverse operation (which may not
exist) or show that all functions embedded in the datatype are
parametric.

In this paper, we show how first-class polymorphism can be used to
guarantee the parametricity of functions embedded in higher-order
abstract syntax. With this restriction, we implement a library of
iteration operators over data-structures containing functionals.  From
this implementation, we derive ``fusion laws'' that functional
programmers may use to reason about the iteration operator.  Finally,
we show how this use of parametric polymorphism corresponds to the
Schuermann, Despeyroux and Pfenning method of enforcing
parametricity through modal types. We do so by using this library to
give a sound and complete encoding of their calculus into System F-omega.
This encoding can serve as a starting point for reasoning about
higher-order structures in polymorphic languages.  } }

%%   note =         {238 pages},
@PhdThesis{weirich:phd,
  plclub =       "yes",
  author = 		  {Stephanie Weirich},
  title = 		  {Programming With Types},
  school = 		  {Cornell University},
  month =        aug,
  year =         2002,
  ps =           "http://www.seas.upenn.edu/~sweirich/papers/thesis/thesis.ps",
  pdf =          "http://www.seas.upenn.edu/~sweirich/papers/thesis/thesis.pdf",
  abstract =
     "Run-time type analysis is an increasingly important linguistic
     mechanism in modern programming languages. Language runtime
     systems use it to implement services such as accurate garbage
     collection, serialization, cloning and structural
     equality. Component frameworks rely on it to provide reflection
     mechanisms so they may discover and interact with program
     interfaces dynamically. Run-time type analysis is also crucial
     for large, distributed systems that must be dynamically extended,
     because it allows those systems to check program invariants when
     new code and new forms of data are added. Finally, many generic
     user-level algorithms for iteration, pattern matching, and
     unification can be defined through type analysis mechanisms.

     However, existing frameworks for run-time type analysis were
     designed for simple type systems. They do not scale well to the
     sophisticated type systems of modern and next-generation
     programming languages that include complex constructs such as
     first-class abstract types, recursive types, objects, and type
     parameterization. In addition, facilities to support type
     analysis often require complicated language semantics that allow
     little freedom in their implementation.  This dissertation
     investigates the foundations of run-time type analysis in the
     context of statically-typed, polymorphic programming languages.
     Its goal is to show how such a language may support
     type-analyzing operations in a way that balances expressiveness,
     safety and simplicity."

}

@InProceedings{weirich:hota,
  plclub =       "yes",
  author = 		  {Stephanie Weirich},
  title = 		  {Higher-Order Intensional Type Analysis},
  booktitle = 	  {11th European Symposium on Programming (ESOP)},
  editor =		  {Daniel Le M\'{e}tayer},
  pages =        {98--114},
  year =         2002,
  month =        apr,
  address =      {Grenoble, France},
  ps =           "http://www.seas.upenn.edu/~sweirich/papers/hota/hota.ps",
  pdf =          "http://www.seas.upenn.edu/~sweirich/papers/hota/hota.pdf",

  abstract = "Intensional type analysis provides the ability to
     analyze abstracted types at run time. In this paper, we extend
     that ability to higher-order and kind-polymorphic type
     constructors. The resulting language is elegant and expressive:
     we show through examples how it extends the repertoire of
     polytypic functions that may be defined."
}


@Article{crary:intensional-journal,
  author    = {Karl Crary and Stephanie Weirich and Greg Morrisett},
  title     = "Intensional Polymorphism in Type Erasure Semantics",
  journal   = "Journal of Functional Programming",
  month     = nov,
  year      = {2002},
  volume    = 12,
  number    = 6,
  pages     = {567--600},
  pdf       = {http://journals.cambridge.org/action/displayFulltext?type=1&fid=129250&jid=JFP&volumeId=12&issueId=06&aid=129249},
  abstract  = "Intensional polymorphism, the ability to dispatch to
     different routines based on types at run time, enables a variety
     of advanced implementation techniques for polymorphic languages,
     including tag-free garbage collection, unboxed function
     arguments, polymorphic marshalling, and flattened data
     structures. To date, languages that support intensional
     polymorphism have required a type-passing (as opposed to
     type-erasure) interpretation where types are constructed and
     passed to polymorphic functions at run time. Unfortunately,
     type-passing suffers from a number of drawbacks; it requires
     duplication of constructs at the term and type levels, it
     prevents abstraction, and it severely complicates polymorphic
     closure conversion.  We present a type-theoretic framework that
     supports intensional polymorphism, but avoids many of the
     disadvantages of type passing. In our approach, run-time type
     information is represented by ordinary terms. This avoids the
     duplication problem, allows us to recover abstraction, and avoids
     complications with closure conversion. In addition, our type
     system provides another improvement in expressiveness; it allows
     unknown types to be refined in place thereby avoiding certain
     beta-expansions required by other frameworks."
}


@inproceedings{weirich01,
  plclub =       "yes",
  author =      "Stephanie Weirich",
  title =       {Encoding Intensional Type Analysis},
  booktitle =   "10th European Symposium on Programming (ESOP)",
  year =        2001,
  editor =      "D. Sands",
  pages =       {92--106},
  address =     {Genova, Italy},
  month =       apr,
  annote =        "2001 Springer-Verlag. Minor corrections in local version.",
  url =         "http://link.springer.de/link/service/series/0558/tocs/t2028.htm",
  ps =          "http://www.seas.upenn.edu/~sweirich/papers/depabs/depabs.ps",
  pdf =         "http://www.seas.upenn.edu/~sweirich/papers/depabs/depabs.pdf",

  abstract = "Languages for intensional type analysis permit ad-hoc
     polymorphism, or run-time analysis of types. However, such
     languages require complex, specialized constructs to support this
     operation, which hinder optimization and complicate the
     meta-theory of these languages. In this paper, we observe that
     such specialized operators need not be intrinsic to the language,
     and in fact, their operation may be simulated through standard
     encodings of iteration in the polymorphic lambda
     calculus. Therefore, we may more easily add intensional analysis
     operators to complicated languages via a translation semantics,
     instead of through language extension."  }


%  note = {An extended and revised version of this paper is
%          Journal Publication \cite{weirich:cast-journal}.}
@inproceedings{weirich00,
  plclub =       "yes",
  author =       "Stephanie Weirich",
  title  =       "Type-Safe Cast: Functional Pearl",
  booktitle =    "Proceedings of the fifth {ACM SIGPLAN} International Conference on Functional Programming (ICFP)",
  year =         2000,
  month =        sep,
  address =      "Montreal, Canada",
  pages =        "58--67",

  abstract = "In a language with non-parametric or ad-hoc
    polymorphism, it is possible to determine the identity of a type
    variable at run time.  With this facility, we can write a function
    to convert a term from one abstract type to another, if the two
    hidden types are identical.  However, the naive implementation of
    this function requires that the term be destructed and rebuilt. In
    this paper, we show how to eliminate this overhead using
    higher-order type abstraction. We demonstrate this solution in two
    frameworks for ad-hoc polymorphism: intensional type analysis and
    type classes.",
  ps = "http://www.seas.upenn.edu/~sweirich/papers/cast/cast.ps",
  pdf = "http://www.seas.upenn.edu/~sweirich/papers/cast/cast.pdf"
  }

@TECHREPORT{HicksW00type-loading-tr,
  plclub =       "yes",
  AUTHOR = {Michael Hicks and Stephanie Weirich},
  TITLE = {A Calculus for Dynamic Loading},
  INSTITUTION = {University of Pennsylvania},
  YEAR = {2000},
  NUMBER = {MS-CIS-00-07},
  MONTH = {April},
  PDF = { http://repository.upenn.edu/cis_reports/169/ },
  ABSTRACT = {
We present the load-calculus, used to model dynamic loading, and prove it sound. The calculus extends the polymorphic lambda-calculus with a load primitive that dynamically loads terms that are closed, with respect to values. The calculus is meant to approximate the process of dynamic loading in TAL/Load , a version of Typed Assembly Language extending with dynamic linking. To model the key aspects of TAL, the calculus contains references and facilities for named types. Loadable programs may refer to named types defined by the running program, and may export new types to code loaded later. Our approach follows the framework initially outlined by Glew et. al. This calculus has been implemented in the TALx86 version of Typed Assembly Language, and is used to implement a full-featured dynamic linking library, DLpop.}
}

@incollection{hicks00,
  plclub =       "yes",
  author = "Michael Hicks and Stephanie Weirich and Karl Crary",
  title =  "Safe and Flexible Dynamic Linking of Native Code",
  booktitle = "Types in Compilation: Third International Workshop, TIC 2000;
               Montreal, Canada, September 21, 2000; Revised Selected Papers",
  editor = "R. Harper",
  publisher = "Springer",
  year = 2001,
  series = "Lecture Notes in Computer Science",
  volume = 2071,
  pages = {147--176},
  annote = "Related technical report: Michael Hicks and Stephanie
     Weirich.  A calculus for dynamic loading.
    University of Pennsylvania Computer and Information Science
     Technical Report,
     MS-CIS-00-07,  April 2000.",

  abstract = "We present the design and implementation of the first
     complete framework for flexible and safe dynamic linking of
     native code. Our approach extends Typed Assembly Language with a
     primitive for loading and typechecking code, which is flexible
     enough to support a variety of linking strategies, but simple
     enough that it does not significantly expand the trusted
     computing base. Using this primitive, along with the ability to
     compute with types, we show that we can program many existing
     dynamic linking approaches. As a concrete demonstration, we have
     used our framework to implement dynamic linking for a type-safe
     dialect of C, closely modeled after the standard linking facility
     for Unix C programs. Aside from the unavoidable cost of
     verification, our implementation performs comparably with the
     standard, untyped approach.",

  url = "http://link.springer.de/link/service/series/0558/tocs/t2071.htm",
  ps = "http://www.seas.upenn.edu/~sweirich/papers/taldynlink/taldynlink.ps.gz",
  pdf = "http://www.seas.upenn.edu/~sweirich/papers/taldynlink/taldynlink.pdf"

}


@InProceedings{crary00,
  plclub =       "yes",
  author =	 {Karl Crary and Stephanie Weirich},
  title =	 "Resource Bound Certification",
  booktitle =	 "The Twenty-Seventh {ACM} {SIGPLAN}-{SIGACT} Symposium on Principles of Programming Languages (POPL)",
  pages =	 {184--198},
  year =	 2000,
  address =	 "Boston, MA, USA",
  month =	 jan,
  pdf =          "http://www.seas.upenn.edu/~sweirich/papers/res/res.pdf",
  ps =          "http://www.seas.upenn.edu/~sweirich/papers/res/res.ps.gz",


  abstract = "Various code certification systems allow the
    certification and static verification of a variety of important
    safety properties such as memory safety and control-flow
    safety. These systems provide valuable tools for verifying that
    untrusted and potentially malicious code is safe before execution.
    However, one important safety property that is not usually
    included is that programs adhere to specific bounds on resource
    consumption, such as running time.

    We present a decidable type system capable of specifying and
    certifying bounds on resource consumption. Our system makes two
    advances over previous resource bound certification systems, both
    of which are necessary for a practical system: we allow the
    execution time of programs and their subroutines to vary,
    depending on their arguments, and we provide a fully automatic
    compiler generating certified executables from source-level
    programs. The principal device in our approach is a strategy for
    simulating dependent types using sum and inductive kinds. "
}

@inproceedings{morrisett:talx86,
  plclub =       "yes",
  author =	 "Greg Morrisett and Karl Crary and Neal Glew and Dan
                  Grossman and Richard Samuels and Frederick Smith and
                  David Walker and Stephanie Weirich and Steve
                  Zdancewic",
  title =	 "{TALx86}: A Realistic Typed Assembly Language",
  booktitle =	"Second {ACM} {SIGPLAN} Workshop on Compiler Support for System Software",
  year =	 1999,
  month =	 may,
  pages =        "25--35",
  note =         "Published as {INRIA} research report number 0228, March 1999.",
  address =	 "Atlanta, GA, USA",
  ps =           "http://www.seas.upenn.edu/~sweirich/papers/talx86-wcsss.ps",
  pdf =           "http://www.seas.upenn.edu/~sweirich/papers/talx86-wcsss.pdf",

  abstract = "The goal of typed assembly language (TAL) is to provide
     a low-level, statically typed target language that is better
     suited than Java bytecodes for supporting a wide variety of
     source languages and a number of important optimizations. In
     previous work, we formalized idealized versions of TAL and proved
     important safety properties about them. In this paper, we present
     our progress in defining and implementing a realistic typed
     assembly language called TALx86. The TALx86 instructions comprise
     a relatively complete fragment of the Intel IA32 (32-bit 80x86
     flat model) assembly language and are thus executable on
     processors such as the Intel Pentium. The type system for the
     language incorporates a number of advanced features necessary for
     safely compiling large programs to good code.

     To motivate the design of the type system, we demonstrate how
     various high-level language features are compiled to TALx86. For
     this purpose, we present a type-safe C-like language called
     Popcorn.",
}




@inproceedings{crary:lx,
  plclub =       "yes",
  author =	 "Karl Crary and Stephanie Weirich",
  title =	 "Flexible Type Analysis",
  booktitle = "Proceedings of the fourth {ACM SIGPLAN} International Conference on Functional Programming (ICFP) ",
  year =	 1999,
  month =	 sep,
  address =	 "Paris, France",
  pages =	 "233--248",

  abstract = "Run-time type dispatch enables a variety of advanced
     optimization techniques for polymorphic languages, including
     tag-free garbage collection, unboxed function arguments, and
     flattened data structures.  However, modern type-preserving
     compilers transform types between stages of compilation, making
     type dispatch prohibitively complex at low levels of typed
     compilation. It is crucial therefore for type analysis at these
     low levels to refer to the types of previous
     stages. Unfortunately, no current intermediate language supports
     this facility.

     To fill this gap, we present the language LX, which provides a
     rich language of type constructors supporting type analysis
     (possibly of previous-stage types) as a programming idiom. This
     language is quite flexible, supporting a variety of other
     applications such as analysis of quantified types, analysis with
     incomplete type information, and type classes. We also show that
     LX is compatible with a type-erasure semantics.",

   ps  =      "http://www.seas.upenn.edu/~sweirich/papers/lx/lxpaper.ps.gz",
   pdf =      "http://www.seas.upenn.edu/~sweirich/papers/lx/lxpaper.pdf"
}


%  note =    "An extended and revised version of this paper is Journal Publication
%              \cite{crary:intensional-journal}.",
@InProceedings{crary:intensional,
  plclub =       "yes",
  author = 	 {Karl Crary and Stephanie Weirich and Greg Morrisett},
  title = 	 "Intensional Polymorphism in Type Erasure Semantics",
  booktitle = "Proceedings of the third {ACM SIGPLAN} International Conference on Functional Programming (ICFP) ",
  year =	 1998,
  address =	 {Baltimore, MD, USA},
  month =	 sep,
  pages =   "301--313",
  ps = "http://www.seas.upenn.edu/~sweirich/papers/typepass/typepass.ps",
  pdf = "http://www.seas.upenn.edu/~sweirich/papers/typepass/typepass.pdf",

  abstract = { Intensional polymorphism, the ability to dispatch to
  different routines based on types at run time, enables a variety of
  advanced implementation techniques for polymorphic languages,
  including tag-free garbage collection, unboxed function arguments,
  polymorphic marshalling, and flattened data structures. To date,
  languages that support intensional polymorphism have required a
  type-passing (as opposed to type-erasure) interpretation where types
  are constructed and passed to polymorphic functions at run
  time. Unfortunately, type-passing suffers from a number of
  drawbacks; it requires duplication of constructs at the term and
  type levels, it prevents abstraction, and it severely complicates
  polymorphic closure conversion. We present a type-theoretic
  framework that supports intensional polymorphism, but avoids many of
  the disadvantages of type passing. In our approach, run-time type
  information is represented by ordinary terms. This avoids the
  duplication problem, allows us to recover abstraction, and avoids
  complications with closure conversion. In addition, our type system
  provides another improvement in expressiveness; it allows unknown
  types to be refined in place thereby avoiding certain
  beta-expansions required by other frameworks.  } }


@TechReport{crary98a,
  author = 	 {Karl Crary and Stephanie Weirich and Greg Morrisett},
  title = 	 {Intensional Polymorphism in Type Erasure Semantics
              (Extended Version)},
  institution =  {Cornell University, Computer Science},
  year = 	 1998,
  number =	 {TR98-1721},
  month =	 nov,
  ps = "http://www.seas.upenn.edu/~sweirich/papers/typepass/typepass-tr.ps",
  pdf = "http://www.seas.upenn.edu/~sweirich/papers/typepass/typepass-tr.pdf"
}


@inproceedings{flanagan96,
  plclub =       "yes",
   author = "Cormac Flanagan and Matthew Flatt and Shriram
             Krishnamurthi and Stephanie Weirich and Matthias
             Felleisen",
   title =  "Catching Bugs in the Web of Program Invariants",
   booktitle = "{ACM SIGPLAN} Conference on Programming Language Design and Implementation (PLDI)",
   year = 1996,
   pages = "23--32",
   abstract = "MrSpidey is a user-friendly, interactive static
     debugger for Scheme. A static debugger supplements the standard
     debugger by analyzing the program and pinpointing those program
     operations tha may cause run-time errors suce as dereferencing
     the null pointer or applying non-functions. The program analysis
     of MrSpidey computes value set descriptions for each term in the
     program and constructs a value flow graph connecting the set
     descriptions. Using the set descriptions, MrSpidey can identify
     and highlight potentially erroneous program operations, whose
     cause the programmer can the explore by selectively exposing
     portions of the value flow graph.",

   Ps = "http://www.seas.upenn.edu/~sweirich/papers/pldi96-ffkwf.ps",
   pdf = "http://www.seas.upenn.edu/~sweirich/papers/pldi96-ffkwf.pdf"
}
